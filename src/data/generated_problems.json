[
  {
    "id": 1000,
    "title": "Fruit Basket Analysis",
    "difficulty": "beginner",
    "category": "Hash Maps",
    "description": "You are given a list of fruits in a basket. Each fruit is represented by its name. Your task is to return a dictionary where the keys are the unique fruit names and the values are the counts of each fruit in the basket.",
    "examples": [
      {
        "input": "[\"apple\", \"banana\", \"apple\", \"orange\"]",
        "output": "{\"apple\": 2, \"banana\": 1, \"orange\": 1}"
      },
      {
        "input": "[\"mango\", \"mango\", \"mango\"]",
        "output": "{\"mango\": 3}"
      },
      {
        "input": "[\"grape\", \"pear\", \"watermelon\"]",
        "output": "{\"grape\": 1, \"pear\": 1, \"watermelon\": 1}"
      }
    ],
    "starterCode": "function countFruits(basket) {\n  // Your solution here\n  \n}",
    "testCases": [
      {
        "input": [
          [
            "apple",
            "banana",
            "apple",
            "orange"
          ]
        ],
        "expected": {
          "apple": 2,
          "banana": 1,
          "orange": 1
        }
      },
      {
        "input": [
          [
            "mango",
            "mango",
            "mango"
          ]
        ],
        "expected": {
          "mango": 3
        }
      },
      {
        "input": [
          [
            "grape",
            "pear",
            "watermelon"
          ]
        ],
        "expected": {
          "grape": 1,
          "pear": 1,
          "watermelon": 1
        }
      },
      {
        "input": [
          []
        ],
        "expected": {}
      },
      {
        "input": [
          [
            "apple"
          ]
        ],
        "expected": {
          "apple": 1
        }
      }
    ],
    "functionName": "countFruits",
    "hints": [
      "Hint 1: Use a dictionary to keep track of the counts of each fruit. This will allow you to look up and update the counts efficiently.",
      "Hint 2: Iterate through the list of fruits and for each fruit, check if it is already in the dictionary. If it is, increment its count. If not, add it to the dictionary with a count of 1.",
      "Hint 3: Consider what happens when the input list is empty. Make sure your solution handles this edge case correctly and returns an empty dictionary."
    ]
  },
  {
    "id": 1001,
    "title": "Calculating GCD of Multiple Numbers",
    "difficulty": "intermediate",
    "category": "Math",
    "description": "Given a list of integers, calculate the greatest common divisor (GCD) of all the numbers in the list. The GCD of a list of numbers is the largest number that divides all numbers in the list without leaving a remainder.",
    "examples": [
      {
        "input": "[2, 4, 6]",
        "output": "2"
      },
      {
        "input": "[12, 18, 24]",
        "output": "6"
      },
      {
        "input": "[7, 11, 13]",
        "output": "1"
      }
    ],
    "starterCode": "function calculateGcd(...args) {\n  // Your solution here\n  \n}",
    "testCases": [
      {
        "input": [
          [
            2,
            4,
            6
          ]
        ],
        "expected": 2
      },
      {
        "input": [
          [
            12,
            18,
            24
          ]
        ],
        "expected": 6
      },
      {
        "input": [
          [
            7,
            11,
            13
          ]
        ],
        "expected": 1
      },
      {
        "input": [
          [
            1,
            1,
            1
          ]
        ],
        "expected": 1
      },
      {
        "input": [
          [
            17,
            17,
            17
          ]
        ],
        "expected": 17
      }
    ],
    "functionName": "calculateGcd",
    "hints": [
      "Hint 1: Use the Euclidean algorithm to find the GCD of two numbers, then extend this approach to find the GCD of multiple numbers.",
      "Hint 2: Consider using a recursive function or a loop to repeatedly apply the GCD calculation to the list of numbers.",
      "Hint 3: To handle edge cases like an empty list or a list with a single element, consider adding input validation to return a default value or handle these cases explicitly."
    ]
  },
  {
    "id": 1002,
    "title": "Finding the Peak Element in a 2D Array",
    "difficulty": "advanced",
    "category": "Binary Search",
    "description": "Given a 2D array of integers with a specific structure, find the peak element. A peak element is an element that is greater than or equal to its neighbors. The 2D array is structured in such a way that each row is sorted in ascending order and each column is sorted in ascending order. If there are multiple peak elements, return the one at the smallest row and column index.",
    "examples": [
      {
        "input": "[[1, 2, 3], [4, 5, 6], [7, 8, 9]]",
        "output": "9"
      },
      {
        "input": "[[1, 3, 5], [2, 6, 9], [3, 6, 9]]",
        "output": "9"
      },
      {
        "input": "[[1, 2, 3, 4, 5], [6, 7, 8, 9, 10], [11, 12, 13, 14, 15]]",
        "output": "15"
      }
    ],
    "starterCode": "function findPeakElement(matrix) {\n  // Your solution here\n  \n}",
    "testCases": [
      {
        "input": [
          [
            [
              1,
              2,
              3
            ],
            [
              4,
              5,
              6
            ],
            [
              7,
              8,
              9
            ]
          ]
        ],
        "expected": 9
      },
      {
        "input": [
          [
            [
              1,
              3,
              5
            ],
            [
              2,
              6,
              9
            ],
            [
              3,
              6,
              9
            ]
          ]
        ],
        "expected": 9
      },
      {
        "input": [
          [
            [
              1,
              2,
              3,
              4,
              5
            ],
            [
              6,
              7,
              8,
              9,
              10
            ],
            [
              11,
              12,
              13,
              14,
              15
            ]
          ]
        ],
        "expected": 15
      },
      {
        "input": [
          [
            [
              -1,
              -2,
              -3
            ],
            [
              -4,
              -5,
              -6
            ],
            [
              -7,
              -8,
              -9
            ]
          ]
        ],
        "expected": -1
      },
      {
        "input": [
          [
            []
          ]
        ],
        "expected": null
      }
    ],
    "functionName": "findPeakElement",
    "hints": [
      "Hint 1: Start by understanding the structure of the 2D array and how the elements are related to each other. Consider how you can use this structure to narrow down the search for the peak element.",
      "Hint 2: Since each row and column is sorted in ascending order, you can use a modified binary search approach to find the peak element. Think about how you can use the properties of the sorted rows and columns to guide your search.",
      "Hint 3: When searching for the peak element, consider the edges of the 2D array. What happens if the peak element is at the edge of the array? How can you handle these cases in your solution?"
    ]
  },
  {
    "id": 1003,
    "title": "stringReversalWithSpecialChars",
    "difficulty": "beginner",
    "category": "Strings",
    "description": "Write a function that takes a string as input and returns the string with all alphanumeric characters reversed, while keeping the non-alphanumeric characters in their original positions. The input string can contain letters (both uppercase and lowercase), digits, and special characters.",
    "examples": [
      {
        "input": "abc123!@#",
        "output": "321cba!@#"
      },
      {
        "input": "hello world!",
        "output": "dlrow olleh!"
      },
      {
        "input": "a1b2c3!@#",
        "output": "3c2b1a!@#"
      }
    ],
    "starterCode": "function reverseStringWithSpecialChars(str) {\n  // Your solution here\n  \n}",
    "testCases": [
      {
        "input": [
          "abc123!@#"
        ],
        "expected": "321cba!@#"
      },
      {
        "input": [
          "hello world!"
        ],
        "expected": "dlrow olleh!"
      },
      {
        "input": [
          "a1b2c3!@#"
        ],
        "expected": "3c2b1a!@#"
      },
      {
        "input": [
          "!@#$%^&*()"
        ],
        "expected": "!@#$%^&*()"
      },
      {
        "input": [
          "1234567890"
        ],
        "expected": "9876543210"
      }
    ],
    "functionName": "reverseStringWithSpecialChars",
    "hints": [
      "Hint 1: Use two pointers to traverse the string from both ends towards the center, swapping alphanumeric characters along the way.",
      "Hint 2: Use a conditional statement to check if a character is alphanumeric before swapping it, and make sure to handle the case when the string has an odd length.",
      "Hint 3: Consider using the built-in JavaScript methods for checking if a character is alphanumeric, such as the RegExp test() method or the isNaN() function in combination with the String.fromCharCode() method."
    ]
  },
  {
    "id": 1004,
    "title": "Minimum Cost to Connect All Cities",
    "difficulty": "intermediate",
    "category": "Graphs",
    "description": "In a country with n cities, there are roads connecting some pairs of cities. The cost of building each road is given. Find the minimum cost to connect all cities. Assume that the cost of building a road is the same in both directions and that the graph does not contain any self-loops or multiple edges between the same pair of cities.",
    "examples": [
      {
        "input": "[[0, 1, 10], [0, 2, 6], [0, 3, 5], [1, 3, 15], [2, 3, 4]]",
        "output": "19"
      },
      {
        "input": "[[0, 1, 5], [1, 2, 3], [2, 3, 1], [3, 0, 2]]",
        "output": "7"
      },
      {
        "input": "[[0, 1, 2], [0, 2, 3], [1, 2, 1], [1, 3, 4], [2, 3, 5]]",
        "output": "6"
      }
    ],
    "starterCode": "function minimumCostToConnectCities(edges) {\n  // Your solution here\n  \n}",
    "testCases": [
      {
        "input": [
          [
            [
              0,
              1,
              10
            ],
            [
              0,
              2,
              6
            ],
            [
              0,
              3,
              5
            ],
            [
              1,
              3,
              15
            ],
            [
              2,
              3,
              4
            ]
          ]
        ],
        "expected": 19
      },
      {
        "input": [
          [
            [
              0,
              1,
              5
            ],
            [
              1,
              2,
              3
            ],
            [
              2,
              3,
              1
            ],
            [
              3,
              0,
              2
            ]
          ]
        ],
        "expected": 7
      },
      {
        "input": [
          [
            [
              0,
              1,
              2
            ],
            [
              0,
              2,
              3
            ],
            [
              1,
              2,
              1
            ],
            [
              1,
              3,
              4
            ],
            [
              2,
              3,
              5
            ]
          ]
        ],
        "expected": 6
      },
      {
        "input": [
          [
            [
              0,
              1,
              1
            ],
            [
              1,
              2,
              1
            ],
            [
              2,
              3,
              1
            ],
            [
              3,
              0,
              1
            ]
          ]
        ],
        "expected": 3
      },
      {
        "input": [
          [
            [
              0,
              1,
              1
            ],
            [
              0,
              2,
              2
            ],
            [
              0,
              3,
              3
            ],
            [
              1,
              2,
              1
            ],
            [
              1,
              3,
              2
            ],
            [
              2,
              3,
              1
            ]
          ]
        ],
        "expected": 3
      }
    ],
    "functionName": "minimumCostToConnectCities",
    "hints": [
      "Hint 1: This problem can be solved by using a minimum spanning tree algorithm, which is a subset of the edges in the graph that connect all the vertices together while minimizing the total edge cost.",
      "Hint 2: To implement the minimum spanning tree algorithm, you can use Kruskal's algorithm, which sorts all the edges by their cost and then adds them to the minimum spanning tree one by one, as long as they do not form a cycle.",
      "Hint 3: To detect cycles when adding a new edge to the minimum spanning tree, you can use a disjoint set data structure, which allows you to check whether two vertices are in the same connected component in constant time."
    ]
  },
  {
    "id": 1005,
    "title": "Minimum Window Substring With Exclusion",
    "difficulty": "advanced",
    "category": "Strings",
    "description": "Given two strings s and t, and a set of characters to exclude, find the minimum window substring of s that contains all characters in t and excludes all characters in the exclusion set. If no such window exists, return an empty string.",
    "examples": [
      {
        "input": "'abcabcbb', 'abc', ['b']",
        "output": "'ca'"
      },
      {
        "input": "'abcdef', 'def', ['a', 'b']",
        "output": "'def'"
      },
      {
        "input": "'aaaaaa', 'aa', ['a']",
        "output": "''"
      }
    ],
    "starterCode": "function minWindowSubstring(...args) {\n  // Your solution here\n  \n}",
    "testCases": [
      {
        "input": [
          "abcabcbb",
          "abc",
          [
            "b"
          ]
        ],
        "expected": "ca"
      },
      {
        "input": [
          "abcdef",
          "def",
          [
            "a",
            "b"
          ]
        ],
        "expected": "def"
      },
      {
        "input": [
          "aaaaaa",
          "aa",
          [
            "a"
          ]
        ],
        "expected": ""
      }
    ],
    "functionName": "minWindowSubstring",
    "hints": [
      "Hint 1: Use a sliding window approach to efficiently scan the string s and find the minimum window that meets the conditions.",
      "Hint 2: Utilize a frequency count data structure to keep track of the characters in t and the exclusion set, and update this data structure as the window moves.",
      "Hint 3: Consider using a flag to track whether all characters in t are currently included in the window, and use this flag to determine when to update the minimum window substring."
    ]
  },
  {
    "id": 1007,
    "title": "Bookshelf Organization",
    "difficulty": "intermediate",
    "category": "Binary Search",
    "description": "You are given a list of book heights and a shelf width. You need to arrange the books on the shelf such that the total height of the books on the shelf does not exceed the shelf width. The goal is to find the minimum number of shelves required to arrange all the books. The books can be arranged in any order on the shelves.",
    "examples": [
      {
        "input": "[1, 2, 3, 4, 5], 5",
        "output": "3"
      },
      {
        "input": "[10, 20, 30, 40, 50], 100",
        "output": "3"
      },
      {
        "input": "[1, 1, 1, 1, 1], 2",
        "output": "3"
      }
    ],
    "starterCode": "function minShelves(bookHeights, shelfWidth) {\n  // Your solution here\n  \n}",
    "testCases": [
      {
        "input": [
          [
            1,
            2,
            3,
            4,
            5
          ],
          5
        ],
        "expected": 3
      },
      {
        "input": [
          [
            10,
            20,
            30,
            40,
            50
          ],
          100
        ],
        "expected": 3
      },
      {
        "input": [
          [
            1,
            1,
            1,
            1,
            1
          ],
          2
        ],
        "expected": 3
      },
      {
        "input": [
          [
            5,
            5,
            5,
            5,
            5
          ],
          10
        ],
        "expected": 2
      },
      {
        "input": [
          [
            1
          ],
          10
        ],
        "expected": 1
      }
    ],
    "functionName": "minShelves",
    "hints": [
      "Hint 1: Use a binary search approach to find the minimum number of shelves. Consider the search space to be the possible number of shelves.",
      "Hint 2: For a given number of shelves, use a greedy approach to arrange the books on the shelves. Try to fill the current shelf as much as possible before moving to the next shelf.",
      "Hint 3: When checking if it's possible to arrange the books on a given number of shelves, consider the maximum height of the books that can be accommodated on each shelf. Use this information to determine the feasibility of the arrangement."
    ]
  },
  {
    "id": 1008,
    "title": "Merging K Sorted Linked Lists",
    "difficulty": "advanced",
    "category": "Linked Lists",
    "description": "Given K sorted linked lists, merge them into one sorted linked list. The input linked lists are non-empty and the nodes are non-null. The output should be a new sorted linked list. Each node in the linked list has a unique value.",
    "examples": [
      {
        "input": "[[1, 4, 5], [1, 3, 4], [2, 6]]",
        "output": "[1, 1, 2, 3, 4, 4, 5, 6]"
      },
      {
        "input": "[[1, 2, 3], [4, 5, 6]]",
        "output": "[1, 2, 3, 4, 5, 6]"
      },
      {
        "input": "[[1], [2], [3]]",
        "output": "[1, 2, 3]"
      }
    ],
    "starterCode": "function mergeKLists(...lists) {\n  // Your solution here\n  \n}",
    "testCases": [
      {
        "input": [
          [
            [
              1,
              4,
              5
            ],
            [
              1,
              3,
              4
            ],
            [
              2,
              6
            ]
          ]
        ],
        "expected": [
          1,
          1,
          2,
          3,
          4,
          4,
          5,
          6
        ]
      },
      {
        "input": [
          [
            [
              1,
              2,
              3
            ],
            [
              4,
              5,
              6
            ]
          ]
        ],
        "expected": [
          1,
          2,
          3,
          4,
          5,
          6
        ]
      },
      {
        "input": [
          [
            [
              1
            ],
            [
              2
            ],
            [
              3
            ]
          ]
        ],
        "expected": [
          1,
          2,
          3
        ]
      },
      {
        "input": [
          [
            [
              1
            ],
            [
              1
            ],
            [
              1
            ]
          ]
        ],
        "expected": [
          1,
          1,
          1
        ]
      },
      {
        "input": [
          [
            [],
            [
              1,
              2,
              3
            ]
          ]
        ],
        "expected": [
          1,
          2,
          3
        ]
      }
    ],
    "functionName": "mergeKLists",
    "hints": [
      "Hint 1: You can use a min-heap data structure to store the current smallest node from each linked list",
      "Hint 2: You need to keep track of the current node in each linked list and update the min-heap when a node is popped",
      "Hint 3: You should consider the case when one or more linked lists are empty, and handle this case properly"
    ]
  },
  {
    "id": 1009,
    "title": "Knight Tour",
    "difficulty": "beginner",
    "category": "Backtracking",
    "description": "Given a square chessboard of size n x n, find all possible tours that a knight can make, visiting each square exactly once. The knight moves in an L-shape (two spaces in one direction, then one space to the side).",
    "examples": [
      {
        "input": "4",
        "output": "[[0, 0], [2, 1], [1, 3], [3, 2], [1, 1], [3, 0], [0, 2], [2, 3], [1, 0], [0, 1], [2, 2], [3, 1], [1, 2], [0, 3], [2, 0], [3, 3]]"
      },
      {
        "input": "3",
        "output": "No solution"
      },
      {
        "input": "6",
        "output": "[[0, 0], [2, 1], [4, 2], [5, 0], [3, 1], [0, 2], [1, 3], [3, 2], [5, 1], [4, 0], [2, 2], [0, 1], [1, 0], [3, 0], [5, 2], [2, 0], [0, 3], [4, 1], [1, 2], [3, 3], [5, 3], [4, 3], [2, 3], [1, 1], [0, 4], [2, 4], [4, 4], [5, 4], [3, 4], [1, 4]]"
      }
    ],
    "starterCode": "function knightTour(n) {\n  // Your solution here\n  \n}",
    "testCases": [
      {
        "input": [
          4
        ],
        "expected": [
          [
            0,
            0
          ],
          [
            2,
            1
          ],
          [
            1,
            3
          ],
          [
            3,
            2
          ],
          [
            1,
            1
          ],
          [
            3,
            0
          ],
          [
            0,
            2
          ],
          [
            2,
            3
          ],
          [
            1,
            0
          ],
          [
            0,
            1
          ],
          [
            2,
            2
          ],
          [
            3,
            1
          ],
          [
            1,
            2
          ],
          [
            0,
            3
          ],
          [
            2,
            0
          ],
          [
            3,
            3
          ]
        ]
      },
      {
        "input": [
          3
        ],
        "expected": "No solution"
      },
      {
        "input": [
          6
        ],
        "expected": [
          [
            0,
            0
          ],
          [
            2,
            1
          ],
          [
            4,
            2
          ],
          [
            5,
            0
          ],
          [
            3,
            1
          ],
          [
            0,
            2
          ],
          [
            1,
            3
          ],
          [
            3,
            2
          ],
          [
            5,
            1
          ],
          [
            4,
            0
          ],
          [
            2,
            2
          ],
          [
            0,
            1
          ],
          [
            1,
            0
          ],
          [
            3,
            0
          ],
          [
            5,
            2
          ],
          [
            2,
            0
          ],
          [
            0,
            3
          ],
          [
            4,
            1
          ],
          [
            1,
            2
          ],
          [
            3,
            3
          ],
          [
            5,
            3
          ],
          [
            4,
            3
          ],
          [
            2,
            3
          ],
          [
            1,
            1
          ],
          [
            0,
            4
          ],
          [
            2,
            4
          ],
          [
            4,
            4
          ],
          [
            5,
            4
          ],
          [
            3,
            4
          ],
          [
            1,
            4
          ]
        ]
      }
    ],
    "functionName": "knightTour",
    "hints": [
      "Hint 1: Start by representing the chessboard as a 2D array or matrix, and think about how you can use backtracking to explore all possible moves.",
      "Hint 2: Consider using a helper function to check if a given move is valid (i.e., within the bounds of the board and not already visited), and use this function to prune the search tree.",
      "Hint 3: When implementing the backtracking algorithm, make sure to restore the board to its previous state after exploring each branch, to avoid modifying the board permanently and to ensure that all possible solutions are explored."
    ]
  },
  {
    "id": 1010,
    "title": "Lowest Common Ancestor of a Binary Tree with Duplicate Values",
    "difficulty": "intermediate",
    "category": "Trees",
    "description": "Given a binary tree and two node values, find the lowest common ancestor of the two nodes. The binary tree can have duplicate values and the nodes do not have to be distinct.",
    "examples": [
      {
        "input": "root = [3, 5, 1, 6, 2, 0, 8, null, null, 7, 4], p = 5, q = 1",
        "output": "3"
      },
      {
        "input": "root = [3, 5, 1, 6, 2, 0, 8, null, null, 7, 4], p = 5, q = 4",
        "output": "5"
      },
      {
        "input": "root = [1, 2], p = 1, q = 2",
        "output": "1"
      }
    ],
    "starterCode": "function lowestCommonAncestor(root, p, q) {\n  // Your solution here\n  \n}",
    "testCases": [
      {
        "input": [
          [
            3,
            5,
            1,
            6,
            2,
            0,
            8,
            null,
            null,
            7,
            4
          ],
          5,
          1
        ],
        "expected": 3
      },
      {
        "input": [
          [
            3,
            5,
            1,
            6,
            2,
            0,
            8,
            null,
            null,
            7,
            4
          ],
          5,
          4
        ],
        "expected": 5
      },
      {
        "input": [
          [
            1,
            2
          ],
          1,
          2
        ],
        "expected": 1
      }
    ],
    "functionName": "lowestCommonAncestor",
    "hints": [
      "Hint 1: Start by thinking about how you can traverse the binary tree to find the lowest common ancestor. Consider using a recursive or iterative approach.",
      "Hint 2: Use a recursive approach to traverse the tree and find the lowest common ancestor. You can use a helper function to perform the recursion.",
      "Hint 3: To handle duplicate values, make sure to check if the current node's value is equal to either p or q, and if so, return the current node. Also, consider using a base case to handle when the tree is empty or when p and q are not found."
    ]
  },
  {
    "id": 1011,
    "title": "Kth Smallest Element in a Dynamic Heap",
    "difficulty": "advanced",
    "category": "Heap",
    "description": "Design a class to find the kth smallest element in a dynamic heap. The heap can be modified by inserting or deleting elements. The class should support the following operations: insert(val), delete(val), and kthSmallest(k). The insert and delete operations should have an average time complexity of O(log n), and the kthSmallest operation should have a time complexity of O(n log n) in the worst case.",
    "examples": [
      {
        "input": "insert(5), insert(3), insert(8), kthSmallest(2)",
        "output": "5"
      },
      {
        "input": "insert(10), insert(20), delete(10), kthSmallest(1)",
        "output": "20"
      },
      {
        "input": "insert(1), insert(2), insert(3), kthSmallest(3)",
        "output": "3"
      }
    ],
    "starterCode": "function dynamicHeap(...args) {\n  // Your solution here\n  \n}",
    "testCases": [
      {
        "input": [
          [
            5
          ],
          [
            3
          ],
          [
            8
          ],
          [
            2
          ]
        ],
        "expected": 5
      },
      {
        "input": [
          [
            10
          ],
          [
            20
          ],
          [
            10
          ],
          [
            1
          ]
        ],
        "expected": 20
      },
      {
        "input": [
          [
            1
          ],
          [
            2
          ],
          [
            3
          ],
          [
            3
          ]
        ],
        "expected": 3
      },
      {
        "input": [
          [
            1
          ],
          [
            2
          ],
          [
            3
          ],
          [
            4
          ],
          [
            5
          ],
          [
            3
          ]
        ],
        "expected": 3
      },
      {
        "input": [
          [],
          [
            1
          ],
          [
            2
          ],
          [
            3
          ],
          [
            1
          ]
        ],
        "expected": 1
      }
    ],
    "functionName": "dynamicHeap",
    "hints": [
      "Hint 1: Use a data structure that supports efficient insertion, deletion, and sorting, such as a binary heap or a balanced binary search tree.",
      "Hint 2: To implement the kthSmallest operation efficiently, consider using a heap data structure and sorting the elements in the heap.",
      "Hint 3: When implementing the delete operation, consider using a lazy deletion approach to avoid shifting elements in the heap, and instead mark the deleted element as removed and ignore it during the kthSmallest operation."
    ]
  },
  {
    "id": 1012,
    "title": "Fair Queue",
    "difficulty": "beginner",
    "category": "Queue",
    "description": "Create a function that simulates a fair queue where tasks are assigned to the first available worker. Each worker has a unique identifier and can only process one task at a time. The function should take in an array of tasks and an array of worker identifiers and return the order in which the tasks will be completed.",
    "examples": [
      {
        "input": "[\"task1\", \"task2\", \"task3\"]",
        "output": "[\"worker1\", \"worker2\", \"worker3\"]"
      },
      {
        "input": "[\"task1\", \"task2\", \"task3\", \"task4\"]",
        "output": "[\"worker1\", \"worker2\", \"worker3\", \"worker1\"]"
      },
      {
        "input": "[\"task1\", \"task2\"]",
        "output": "[\"worker1\", \"worker2\"]"
      }
    ],
    "starterCode": "function fairQueue(tasks, workers) {\n  // Your solution here\n  \n}",
    "testCases": [
      {
        "input": [
          [
            "task1",
            "task2",
            "task3"
          ],
          [
            "worker1",
            "worker2",
            "worker3"
          ]
        ],
        "expected": [
          "worker1",
          "worker2",
          "worker3"
        ]
      },
      {
        "input": [
          [
            "task1",
            "task2",
            "task3",
            "task4"
          ],
          [
            "worker1",
            "worker2",
            "worker3"
          ]
        ],
        "expected": [
          "worker1",
          "worker2",
          "worker3",
          "worker1"
        ]
      },
      {
        "input": [
          [
            "task1",
            "task2"
          ],
          [
            "worker1",
            "worker2",
            "worker3"
          ]
        ],
        "expected": [
          "worker1",
          "worker2"
        ]
      }
    ],
    "functionName": "fairQueue",
    "hints": [
      "Hint 1: Use a queue data structure to keep track of the tasks and workers",
      "Hint 2: Iterate over the tasks and assign each task to the first available worker",
      "Hint 3: Use a modulo operation to cycle through the workers and ensure that each task is assigned to a unique worker"
    ]
  },
  {
    "id": 1013,
    "title": "Merge Alternate Nodes of Two Linked Lists",
    "difficulty": "intermediate",
    "category": "Linked Lists",
    "description": "Given two linked lists, merge their nodes in an alternate manner. For example, given two lists 1 -> 2 -> 3 and 4 -> 5 -> 6, the merged list should be 1 -> 4 -> 2 -> 5 -> 3 -> 6. If one list is longer than the other, the remaining nodes of the longer list should be appended at the end of the merged list.",
    "examples": [
      {
        "input": "list1: 1 -> 2 -> 3, list2: 4 -> 5 -> 6",
        "output": "1 -> 4 -> 2 -> 5 -> 3 -> 6"
      },
      {
        "input": "list1: 1 -> 2, list2: 3 -> 4 -> 5",
        "output": "1 -> 3 -> 2 -> 4 -> 5"
      },
      {
        "input": "list1: 1 -> 2 -> 3 -> 4, list2: 5",
        "output": "1 -> 5 -> 2 -> 3 -> 4"
      }
    ],
    "starterCode": "function mergeAlternateNodes(list1, list2) {\n  // Your solution here\n  \n}",
    "testCases": [
      {
        "input": [
          [
            1,
            2,
            3
          ],
          [
            4,
            5,
            6
          ]
        ],
        "expected": [
          1,
          4,
          2,
          5,
          3,
          6
        ]
      },
      {
        "input": [
          [
            1,
            2
          ],
          [
            3,
            4,
            5
          ]
        ],
        "expected": [
          1,
          3,
          2,
          4,
          5
        ]
      },
      {
        "input": [
          [
            1,
            2,
            3,
            4
          ],
          [
            5
          ]
        ],
        "expected": [
          1,
          5,
          2,
          3,
          4
        ]
      }
    ],
    "functionName": "mergeAlternateNodes",
    "hints": [
      "Hint 1: Start by defining a function that takes the heads of two linked lists as input and returns the head of the merged linked list.",
      "Hint 2: Use a temporary dummy node to simplify the merging process and avoid dealing with null pointer exceptions for the head of the merged list.",
      "Hint 3: After merging the nodes, make sure to handle the case where one list is longer than the other by appending the remaining nodes of the longer list to the end of the merged list."
    ]
  },
  {
    "id": 1015,
    "title": "Island Counter",
    "difficulty": "beginner",
    "category": "Graphs",
    "description": "Given a 2D grid consisting of '1's (land) and '0's (water), count the number of islands. An island is a group of connected '1's. Two '1's are connected if they are adjacent (horizontally or vertically).",
    "examples": [
      {
        "input": "['11110', '11010', '11000', '00000']",
        "output": "1"
      },
      {
        "input": "['11000', '11000', '00100', '00011']",
        "output": "3"
      },
      {
        "input": "['00000', '00000', '00000', '00000']",
        "output": "0"
      }
    ],
    "starterCode": "function countIslands(grid) {\n  // Your solution here\n  \n}",
    "testCases": [
      {
        "input": [
          [
            "1",
            "1",
            "1",
            "1",
            "0"
          ],
          [
            "1",
            "1",
            "0",
            "1",
            "0"
          ],
          [
            "1",
            "1",
            "0",
            "0",
            "0"
          ],
          [
            "0",
            "0",
            "0",
            "0",
            "0"
          ]
        ],
        "expected": 1
      },
      {
        "input": [
          [
            "1",
            "1",
            "0",
            "0",
            "0"
          ],
          [
            "1",
            "1",
            "0",
            "0",
            "0"
          ],
          [
            "0",
            "0",
            "1",
            "0",
            "0"
          ],
          [
            "0",
            "0",
            "0",
            "1",
            "1"
          ]
        ],
        "expected": 3
      },
      {
        "input": [
          [
            "0",
            "0",
            "0",
            "0",
            "0"
          ],
          [
            "0",
            "0",
            "0",
            "0",
            "0"
          ],
          [
            "0",
            "0",
            "0",
            "0",
            "0"
          ],
          [
            "0",
            "0",
            "0",
            "0",
            "0"
          ]
        ],
        "expected": 0
      }
    ],
    "functionName": "countIslands",
    "hints": [
      "Hint 1: Use a depth-first search (DFS) or breadth-first search (BFS) algorithm to traverse the grid and identify connected '1's.",
      "Hint 2: Create a visited matrix or array to keep track of the cells that have been visited to avoid counting the same island multiple times.",
      "Hint 3: Consider using a recursive function for DFS or a queue data structure for BFS to simplify the implementation and handle the traversal efficiently."
    ]
  },
  {
    "id": 1016,
    "title": "Merge Sorted Linked Lists",
    "difficulty": "intermediate",
    "category": "Linked Lists",
    "description": "You are given two sorted linked lists, merge them into one sorted linked list. The nodes of the linked lists are defined as {val, next} where val is the value of the node and next is a pointer to the next node. The input linked lists are sorted in ascending order, and you should merge them into a new sorted linked list in ascending order.",
    "examples": [
      {
        "input": "[1,2,4] and [1,3,4]",
        "output": "[1,1,2,3,4,4]"
      },
      {
        "input": "[1,3,5] and []",
        "output": "[1,3,5]"
      },
      {
        "input": "[] and [1,2,3]",
        "output": "[1,2,3]"
      }
    ],
    "starterCode": "function mergeSortedLists(list1, list2) {\n  // Your solution here\n  \n}",
    "testCases": [
      {
        "input": [
          [
            1,
            2,
            4
          ],
          [
            1,
            3,
            4
          ]
        ],
        "expected": [
          1,
          1,
          2,
          3,
          4,
          4
        ]
      },
      {
        "input": [
          [
            1,
            3,
            5
          ],
          []
        ],
        "expected": [
          1,
          3,
          5
        ]
      },
      {
        "input": [
          [],
          [
            1,
            2,
            3
          ]
        ],
        "expected": [
          1,
          2,
          3
        ]
      },
      {
        "input": [
          [
            -1,
            0,
            1
          ],
          [
            -2,
            2,
            3
          ]
        ],
        "expected": [
          -2,
          -1,
          0,
          1,
          2,
          3
        ]
      }
    ],
    "functionName": "mergeSortedLists",
    "hints": [
      "Hint 1: Use a recursive approach to merge the two linked lists, comparing the current nodes of each list and choosing the smaller value.",
      "Hint 2: To avoid modifying the original linked lists, create a new node for the merged list and update its next pointer accordingly.",
      "Hint 3: Handle the case where one linked list is longer than the other by setting the next pointer of the last node in the merged list to the remaining nodes in the longer list."
    ]
  },
  {
    "id": 1017,
    "title": "Valid Subsequence Parenthesis Stack",
    "difficulty": "advanced",
    "category": "Stack",
    "description": "Write a function to determine the minimum number of parentheses that need to be added to a given string to make it a valid sequence of parentheses. The function should use a stack data structure to keep track of the opening parentheses that do not have a corresponding closing parenthesis yet. The string will only contain parentheses and the function should return the minimum number of parentheses that need to be added.",
    "examples": [
      {
        "input": "((()",
        "output": "1"
      },
      {
        "input": "))()",
        "output": "2"
      },
      {
        "input": "()(()",
        "output": "1"
      }
    ],
    "starterCode": "function minParenthesesToAdd(s) {\n  // Your solution here\n  \n}",
    "testCases": [
      {
        "input": [
          "((()"
        ],
        "expected": 1
      },
      {
        "input": [
          "))()"
        ],
        "expected": 2
      },
      {
        "input": [
          "()(()"
        ],
        "expected": 1
      },
      {
        "input": [
          "()()"
        ],
        "expected": 0
      },
      {
        "input": [
          ""
        ],
        "expected": 0
      }
    ],
    "functionName": "minParenthesesToAdd",
    "hints": [
      "Hint 1: Use a stack to keep track of the opening parentheses, when a closing parenthesis is encountered, pop the stack if it's not empty, if the stack is empty, increment the count of parentheses to add.",
      "Hint 2: Iterate over the string and push opening parentheses onto the stack, when a closing parenthesis is encountered, check if the stack is empty, if it's not, pop the top element.",
      "Hint 3: After iterating over the entire string, the number of elements left in the stack also needs to be added to the count of parentheses to add because these opening parentheses do not have a corresponding closing parenthesis."
    ]
  },
  {
    "id": 1018,
    "title": "Fractional Sum",
    "difficulty": "beginner",
    "category": "Math",
    "description": "Given a list of fractions, calculate the sum of these fractions and return the result as a string in the format 'numerator/denominator'. The input fractions are in the format 'numerator/denominator' and are guaranteed to be valid.",
    "examples": [
      {
        "input": "1/2, 1/4, 1/4",
        "output": "1/1"
      },
      {
        "input": "1/2, 1/3",
        "output": "5/6"
      },
      {
        "input": "1/10, 2/10, 3/10",
        "output": "3/5"
      }
    ],
    "starterCode": "function fractionalSum(...args) {\n  // Your solution here\n  \n}",
    "testCases": [
      {
        "input": [
          "1/2",
          "1/4",
          "1/4"
        ],
        "expected": "1/1"
      },
      {
        "input": [
          "1/2",
          "1/3"
        ],
        "expected": "5/6"
      },
      {
        "input": [
          "1/10",
          "2/10",
          "3/10"
        ],
        "expected": "3/5"
      },
      {
        "input": [
          "1/1"
        ],
        "expected": "1/1"
      },
      {
        "input": [
          "0/1"
        ],
        "expected": "0/1"
      }
    ],
    "functionName": "fractionalSum",
    "hints": [
      "Hint 1: To add fractions, you need to find a common denominator. Think about how you can calculate the least common multiple (LCM) of the denominators.",
      "Hint 2: You can use the formula for the LCM of two numbers, which is the product of the two numbers divided by their greatest common divisor (GCD). Consider how you can extend this to multiple fractions.",
      "Hint 3: To simplify the resulting fraction, you need to find the GCD of the numerator and the denominator. Think about how you can use the Euclidean algorithm to calculate the GCD."
    ]
  },
  {
    "id": 1020,
    "title": "Bitwise Subset Sum",
    "difficulty": "advanced",
    "category": "Bit Manipulation",
    "description": "Given a set of non-negative integers, find the total number of possible subsets where the sum of the elements in the subset is a power of 2. The input set contains unique elements and will have a maximum size of 20.",
    "examples": [
      {
        "input": "[1, 2, 3, 4]",
        "output": "7"
      },
      {
        "input": "[1, 1, 2, 3]",
        "output": "4"
      },
      {
        "input": "[1, 3, 5, 7]",
        "output": "4"
      }
    ],
    "starterCode": "function bitwiseSubsetSum(nums) {\n  // Your solution here\n  \n}",
    "testCases": [
      {
        "input": [
          [
            1,
            2,
            3,
            4
          ]
        ],
        "expected": 7
      },
      {
        "input": [
          [
            1,
            1,
            2,
            3
          ]
        ],
        "expected": 4
      },
      {
        "input": [
          [
            1,
            3,
            5,
            7
          ]
        ],
        "expected": 4
      },
      {
        "input": [
          [
            8,
            16,
            32,
            64
          ]
        ],
        "expected": 8
      },
      {
        "input": [
          [
            1
          ]
        ],
        "expected": 2
      }
    ],
    "functionName": "bitwiseSubsetSum",
    "hints": [
      "Hint 1: Use bitwise operations to generate all possible subsets of the input set and then calculate the sum of each subset.",
      "Hint 2: Utilize a recursive approach or iteration to generate all subsets, and then apply bitwise operations to determine if the sum is a power of 2.",
      "Hint 3: To efficiently check if a number is a power of 2, consider using the property that in binary representation, powers of 2 have exactly one '1' bit and all other bits are '0'."
    ]
  },
  {
    "id": 1021,
    "title": "Find Leaf Node Sums",
    "difficulty": "beginner",
    "category": "Trees",
    "description": "Given a binary tree, find the sum of all leaf node values. A leaf node is a node with no children.",
    "examples": [
      {
        "input": "[1, 2, 3]",
        "output": "5"
      },
      {
        "input": "[4, 2, null, 1, 3]",
        "output": "4"
      },
      {
        "input": "[5, null, 3]",
        "output": "3"
      }
    ],
    "starterCode": "function findLeafNodeSums(root) {\n  // Your solution here\n  \n}",
    "testCases": [
      {
        "input": [
          [
            1,
            2,
            3
          ]
        ],
        "expected": 5
      },
      {
        "input": [
          [
            4,
            2,
            null,
            1,
            3
          ]
        ],
        "expected": 4
      },
      {
        "input": [
          [
            5,
            null,
            3
          ]
        ],
        "expected": 3
      },
      {
        "input": [
          [
            1
          ]
        ],
        "expected": 1
      },
      {
        "input": [
          [
            1,
            2
          ]
        ],
        "expected": 2
      }
    ],
    "functionName": "findLeafNodeSums",
    "hints": [
      "Hint 1: Use recursion to traverse the binary tree, checking each node for leaf node status.",
      "Hint 2: Create a helper function to recursively traverse the tree, adding node values to the sum when a leaf node is encountered.",
      "Hint 3: Be sure to check for null children when determining if a node is a leaf node, and handle base cases for recursion, such as an empty tree."
    ]
  },
  {
    "id": 1022,
    "title": "Single Number III",
    "difficulty": "intermediate",
    "category": "Bit Manipulation",
    "description": "Given an array of integers, every element appears twice except for two elements which appear only once. Find these two elements.",
    "examples": [
      {
        "input": "[1, 2, 1, 3, 2, 5]",
        "output": "[3, 5]"
      },
      {
        "input": "[4, 1, 2, 1, 2]",
        "output": "[4]"
      },
      {
        "input": "[1, 1, 2, 2, 3, 4, 5]",
        "output": "[3, 4, 5]"
      }
    ],
    "starterCode": "function singleNumberIII(nums) {\n  // Your solution here\n  \n}",
    "testCases": [
      {
        "input": [
          [
            1,
            2,
            1,
            3,
            2,
            5
          ]
        ],
        "expected": [
          3,
          5
        ]
      },
      {
        "input": [
          [
            4,
            1,
            2,
            1,
            2
          ]
        ],
        "expected": [
          4
        ]
      },
      {
        "input": [
          [
            1,
            1,
            2,
            2,
            3,
            4,
            5
          ]
        ],
        "expected": [
          3,
          4,
          5
        ]
      }
    ],
    "functionName": "singleNumberIII",
    "hints": [
      "Hint 1: Use bit manipulation to find the XOR of all numbers in the array, which will give you the XOR of the two single numbers.",
      "Hint 2: Use the fact that the XOR of a number and 0 is the number itself, and the XOR of a number and itself is 0, to find the rightmost set bit in the XOR of the two single numbers.",
      "Hint 3: Use a loop to divide the numbers into two groups based on the rightmost set bit, and then find the single numbers in each group using the XOR operation."
    ]
  },
  {
    "id": 1024,
    "title": "Find Consecutive Sums",
    "difficulty": "beginner",
    "category": "Arrays",
    "description": "Given an array of integers, find the longest subarray where the sum of its elements is equal to a given target sum. If there are multiple subarrays with the same maximum length, return the one that appears first in the array.",
    "examples": [
      {
        "input": "[1, 2, 3, 4, 5], 5",
        "output": "[2, 3]"
      },
      {
        "input": "[1, -1, 1, -1, 1], 0",
        "output": "[1, -1]"
      },
      {
        "input": "[5, 5, 5], 15",
        "output": "[5, 5, 5]"
      }
    ],
    "starterCode": "function findConsecutiveSums(arr, targetSum) {\n  // Your solution here\n  \n}",
    "testCases": [
      {
        "input": [
          [
            1,
            2,
            3,
            4,
            5
          ],
          5
        ],
        "expected": [
          2,
          3
        ]
      },
      {
        "input": [
          [
            1,
            -1,
            1,
            -1,
            1
          ],
          0
        ],
        "expected": [
          1,
          -1
        ]
      },
      {
        "input": [
          [
            5,
            5,
            5
          ],
          15
        ],
        "expected": [
          5,
          5,
          5
        ]
      },
      {
        "input": [
          [
            1,
            2,
            3,
            4,
            5
          ],
          10
        ],
        "expected": [
          1,
          2,
          3,
          4
        ]
      },
      {
        "input": [
          [
            -1,
            -2,
            -3,
            -4,
            -5
          ],
          -5
        ],
        "expected": [
          -1,
          -4
        ]
      }
    ],
    "functionName": "findConsecutiveSums",
    "hints": [
      "Hint 1: Use a sliding window approach to iterate over the array and keep track of the current sum of elements in the window.",
      "Hint 2: Use two pointers, one for the start of the window and one for the end, to efficiently move the window and update the sum.",
      "Hint 3: When the sum of the elements in the window exceeds the target sum, move the start pointer to the right to reduce the sum, and when the sum is less than the target sum, move the end pointer to the right to increase the sum."
    ]
  },
  {
    "id": 1025,
    "title": "Min Cost to Connect Islands",
    "difficulty": "intermediate",
    "category": "Graphs",
    "description": "Given a 2D grid representing a map with islands and water, find the minimum cost to connect all islands with bridges. The cost of building a bridge between two adjacent islands is the difference in their heights. The grid is represented as a 2D array of integers, where 0 represents water and any other integer represents the height of an island.",
    "examples": [
      {
        "input": "[[0, 1, 0], [0, 0, 2], [0, 3, 0]]",
        "output": "3"
      },
      {
        "input": "[[0, 0, 0], [0, 1, 0], [0, 0, 2]]",
        "output": "2"
      },
      {
        "input": "[[1, 0, 2], [0, 3, 0], [0, 0, 4]]",
        "output": "5"
      }
    ],
    "starterCode": "function minCostToConnectIslands(grid) {\n  // Your solution here\n}",
    "testCases": [
      {
        "input": [
          [
            0,
            1,
            0
          ],
          [
            0,
            0,
            2
          ],
          [
            0,
            3,
            0
          ]
        ],
        "expected": 3
      },
      {
        "input": [
          [
            0,
            0,
            0
          ],
          [
            0,
            1,
            0
          ],
          [
            0,
            0,
            2
          ]
        ],
        "expected": 2
      },
      {
        "input": [
          [
            1,
            0,
            2
          ],
          [
            0,
            3,
            0
          ],
          [
            0,
            0,
            4
          ]
        ],
        "expected": 5
      }
    ],
    "functionName": "minCostToConnectIslands",
    "hints": [
      "Hint 1: Use a graph data structure to represent the islands and their connections. Think about how you can generate the edges of the graph based on the given grid.",
      "Hint 2: Utilize a minimum spanning tree algorithm, such as Kruskal's algorithm, to find the minimum cost to connect all islands. Consider how you can use a disjoint set data structure to efficiently check if two islands are already connected.",
      "Hint 3: When generating the edges of the graph, be sure to consider all possible connections between adjacent islands, including horizontal and vertical connections. Also, think about how you can handle the case where there are multiple islands with the same height."
    ]
  },
  {
    "id": 1026,
    "title": "Minimum Window Substring with Excluded Characters",
    "difficulty": "advanced",
    "category": "Strings",
    "description": "Given a string and a set of excluded characters, find the minimum window substring that contains all characters in the string, excluding the characters in the excluded set. The window should be a contiguous substring of the original string.",
    "examples": [
      {
        "input": "string: 'abcabc', excluded: 'a'",
        "output": "'bc'"
      },
      {
        "input": "string: 'aaaaa', excluded: 'a'",
        "output": "''"
      },
      {
        "input": "string: 'abcdef', excluded: 'xyz'",
        "output": "'abcdef'"
      }
    ],
    "starterCode": "function minWindowSubstring(...args) {\n  // Your solution here\n  \n}",
    "testCases": [
      {
        "input": [
          "abcabc",
          "a"
        ],
        "expected": "bc"
      },
      {
        "input": [
          "aaaaa",
          "a"
        ],
        "expected": ""
      },
      {
        "input": [
          "abcdef",
          "xyz"
        ],
        "expected": "abcdef"
      },
      {
        "input": [
          "abc",
          ""
        ],
        "expected": "abc"
      },
      {
        "input": [
          "",
          "abc"
        ],
        "expected": ""
      }
    ],
    "functionName": "minWindowSubstring",
    "hints": [
      "Hint 1: Use a sliding window approach to find the minimum window substring.",
      "Hint 2: Utilize a frequency map to track the characters in the current window and the excluded characters.",
      "Hint 3: When updating the minimum window substring, consider the case when the current window has the same length as the minimum window substring, but with a smaller starting index."
    ]
  },
  {
    "id": 1027,
    "title": "Kth Largest Elements",
    "difficulty": "beginner",
    "category": "Heap",
    "description": "Given an array of integers and an integer k, return the kth largest element in the array. You can use the heap data structure to solve this problem efficiently.",
    "examples": [
      {
        "input": "[3, 2, 1, 5, 6, 4], 2",
        "output": "5"
      },
      {
        "input": "[1, 2, 3, 4, 5], 1",
        "output": "5"
      },
      {
        "input": "[5, 5, 5, 5], 1",
        "output": "5"
      }
    ],
    "starterCode": "function kthLargestElements(...args) {\n  // Your solution here\n  \n}",
    "testCases": [
      {
        "input": [
          [
            3,
            2,
            1,
            5,
            6,
            4
          ],
          2
        ],
        "expected": 5
      },
      {
        "input": [
          [
            1,
            2,
            3,
            4,
            5
          ],
          1
        ],
        "expected": 5
      },
      {
        "input": [
          [
            5,
            5,
            5,
            5
          ],
          1
        ],
        "expected": 5
      },
      {
        "input": [
          [
            1,
            2,
            3
          ],
          4
        ],
        "expected": null
      },
      {
        "input": [
          [],
          1
        ],
        "expected": null
      }
    ],
    "functionName": "kthLargestElements",
    "hints": [
      "Hint 1: Use a min heap to store the k largest elements. This will allow you to efficiently remove the smallest element when the heap size exceeds k.",
      "Hint 2: Iterate through the array and push each element into the min heap. If the heap size exceeds k, remove the smallest element from the heap.",
      "Hint 3: After iterating through the entire array, the smallest element in the min heap will be the kth largest element. Be sure to handle edge cases where k is larger than the array length or the array is empty."
    ]
  },
  {
    "id": 1028,
    "title": "Task Scheduler with Queue",
    "difficulty": "intermediate",
    "category": "Queue",
    "description": "You are given a list of tasks with their execution times and a cooldown period. The task scheduler should schedule the tasks in a way that maximizes the CPU utilization while respecting the cooldown period. The tasks are represented as a string where the first character is the task ID and the second character is the execution time. The cooldown period is given as an integer.",
    "examples": [
      {
        "input": "['A1', 'B2', 'A3', 'B4', 'C5'], 2",
        "output": "10"
      },
      {
        "input": "['A1', 'A2', 'A3', 'B4', 'B5'], 3",
        "output": "12"
      },
      {
        "input": "['A1', 'B2', 'C3', 'D4', 'E5'], 1",
        "output": "15"
      }
    ],
    "starterCode": "function scheduleTasks(tasks, cooldown) {\n  // Your solution here\n  \n}",
    "testCases": [
      {
        "input": [
          [
            "A1",
            "B2",
            "A3",
            "B4",
            "C5"
          ],
          2
        ],
        "expected": 10
      },
      {
        "input": [
          [
            "A1",
            "A2",
            "A3",
            "B4",
            "B5"
          ],
          3
        ],
        "expected": 12
      },
      {
        "input": [
          [
            "A1",
            "B2",
            "C3",
            "D4",
            "E5"
          ],
          1
        ],
        "expected": 15
      },
      {
        "input": [
          [
            "A1"
          ],
          2
        ],
        "expected": 1
      },
      {
        "input": [
          [
            "A1",
            "A2"
          ],
          3
        ],
        "expected": 4
      }
    ],
    "functionName": "scheduleTasks",
    "hints": [
      "Hint 1: Use a priority queue to store the tasks that are ready to be executed. The priority queue should be sorted based on the execution time of the tasks.",
      "Hint 2: Use a hashmap to store the cooldown period of each task. The hashmap should be updated whenever a task is executed.",
      "Hint 3: Use a variable to store the current time and update it whenever a task is executed. The current time should be used to check if a task has cooled down and is ready to be executed."
    ]
  },
  {
    "id": 1029,
    "title": "Optimal Resource Allocation in a Dynamic Environment",
    "difficulty": "advanced",
    "category": "Dynamic Programming",
    "description": "Given a set of resources with varying capacities and a list of tasks with different resource requirements, determine the maximum number of tasks that can be completed within the given resource constraints. Each task can be completed in one time unit, and the resources are replenished at the end of each time unit.",
    "examples": [
      {
        "input": "[[1, 2, 3], [[1, 1], [2, 2], [3, 3]]]",
        "output": "2"
      },
      {
        "input": "[[2, 2, 2], [[1, 1, 1], [2, 2, 2], [1, 1, 1]]]",
        "output": "3"
      },
      {
        "input": "[[1, 1, 1], [[1, 1, 1], [2, 2, 2], [3, 3, 3]]]",
        "output": "1"
      }
    ],
    "starterCode": "function optimalResourceAllocation(resourceCapacities, tasks) {\n  // Your solution here\n  \n}",
    "testCases": [
      {
        "input": [
          [
            1,
            2,
            3
          ],
          [
            [
              1,
              1
            ],
            [
              2,
              2
            ],
            [
              3,
              3
            ]
          ]
        ],
        "expected": 2
      },
      {
        "input": [
          [
            2,
            2,
            2
          ],
          [
            [
              1,
              1,
              1
            ],
            [
              2,
              2,
              2
            ],
            [
              1,
              1,
              1
            ]
          ]
        ],
        "expected": 3
      },
      {
        "input": [
          [
            1,
            1,
            1
          ],
          [
            [
              1,
              1,
              1
            ],
            [
              2,
              2,
              2
            ],
            [
              3,
              3,
              3
            ]
          ]
        ],
        "expected": 1
      }
    ],
    "functionName": "optimalResourceAllocation",
    "hints": [
      "Hint 1: Start by analyzing the problem and identifying the key elements: resources, tasks, and the relationship between them. Consider how you can represent these elements in your code.",
      "Hint 2: Use a 2D array or matrix to store the maximum number of tasks that can be completed for each possible combination of resource capacities. This will help you to avoid redundant calculations and improve the efficiency of your solution.",
      "Hint 3: When updating the 2D array, consider the two possible cases: including the current task and excluding the current task. Choose the option that results in the maximum number of tasks completed, taking into account the updated resource capacities."
    ]
  },
  {
    "id": 1030,
    "title": "Peak Finder",
    "difficulty": "beginner",
    "category": "Arrays",
    "description": "Given an array of integers representing mountain heights, find the index of the peak mountain. A peak mountain is defined as the mountain with the highest height. If there are multiple peak mountains, return the index of the first one.",
    "examples": [
      {
        "input": "[1, 2, 3, 4, 5, 4, 3, 2, 1]",
        "output": "4"
      },
      {
        "input": "[5, 4, 3, 2, 1]",
        "output": "0"
      },
      {
        "input": "[1, 1, 1, 1, 1]",
        "output": "0"
      }
    ],
    "starterCode": "function findPeakMountain(arr) {\n  // Your solution here\n  \n}",
    "testCases": [
      {
        "input": [
          [
            1,
            2,
            3,
            4,
            5,
            4,
            3,
            2,
            1
          ]
        ],
        "expected": 4
      },
      {
        "input": [
          [
            5,
            4,
            3,
            2,
            1
          ]
        ],
        "expected": 0
      },
      {
        "input": [
          [
            1,
            1,
            1,
            1,
            1
          ]
        ],
        "expected": 0
      },
      {
        "input": [
          [
            1,
            2,
            3,
            3,
            2,
            1
          ]
        ],
        "expected": 2
      },
      {
        "input": [
          [
            1
          ]
        ],
        "expected": 0
      }
    ],
    "functionName": "findPeakMountain",
    "hints": [
      "Hint 1: Iterate through the array to find the maximum height",
      "Hint 2: Keep track of the index of the maximum height found so far",
      "Hint 3: Consider the case where the array has only one element"
    ]
  },
  {
    "id": 1031,
    "title": "Integer Factorization",
    "difficulty": "intermediate",
    "category": "Math",
    "description": "Write a function to factorize a given integer into its prime factors and return them as a list of objects, where each object contains the prime factor and its power. For example, the prime factorization of 100 is 2^2 * 5^2, so the function should return [{2, 2}, {5, 2}].",
    "examples": [
      {
        "input": "100",
        "output": "[{2, 2}, {5, 2}]"
      },
      {
        "input": "13",
        "output": "[{13, 1}]"
      },
      {
        "input": "24",
        "output": "[{2, 3}, {3, 1}]"
      }
    ],
    "starterCode": "function factorize(n) {\n  // Your solution here\n  \n}",
    "testCases": [
      {
        "input": [
          100
        ],
        "expected": [
          [
            2,
            2
          ],
          [
            5,
            2
          ]
        ]
      },
      {
        "input": [
          13
        ],
        "expected": [
          [
            13,
            1
          ]
        ]
      },
      {
        "input": [
          24
        ],
        "expected": [
          [
            2,
            3
          ],
          [
            3,
            1
          ]
        ]
      },
      {
        "input": [
          1
        ],
        "expected": []
      },
      {
        "input": [
          0
        ],
        "expected": []
      }
    ],
    "functionName": "factorize",
    "hints": [
      "Hint 1: Start by finding the smallest prime factor of the given number and divide it as long as it's divisible. Then, move on to the next number.",
      "Hint 2: Use a loop to check each number up to the square root of the given number to see if it's a factor. If it is, divide the number and keep track of the factor and its power.",
      "Hint 3: To handle the case where the given number itself is a prime number, make sure to add it to the result list with a power of 1 after the loop finishes."
    ]
  },
  {
    "id": 1032,
    "title": "Find Lowest Common Ancestor in a Binary Tree with Duplicate Values",
    "difficulty": "advanced",
    "category": "Trees",
    "description": "Given a binary tree with duplicate values and two node values, find the lowest common ancestor of the two nodes. If the two nodes are not present in the tree, return null. The tree nodes have a value and two children, left and right.",
    "examples": [
      {
        "input": "[3, 5, 1, 6, 2, 0, 8, null, null, 7, 4]",
        "output": "5"
      },
      {
        "input": "[3, 5, 1, 6, 2, 0, 8, null, null, 7, 4]",
        "output": "3"
      },
      {
        "input": "[1, 2]",
        "output": "1"
      }
    ],
    "starterCode": "function findLowestCommonAncestor(root, p, q) {\n  // Your solution here\n  \n}",
    "testCases": [
      {
        "input": [
          [
            3,
            5,
            1,
            6,
            2,
            0,
            8,
            null,
            null,
            7,
            4
          ],
          5,
          1
        ],
        "expected": 3
      },
      {
        "input": [
          [
            3,
            5,
            1,
            6,
            2,
            0,
            8,
            null,
            null,
            7,
            4
          ],
          5,
          4
        ],
        "expected": 5
      },
      {
        "input": [
          [
            1,
            2
          ],
          1,
          2
        ],
        "expected": 1
      }
    ],
    "functionName": "findLowestCommonAncestor",
    "hints": [
      "Hint 1: Start by understanding the structure of the binary tree and how to traverse it. You can use recursive or iterative approaches to find the lowest common ancestor.",
      "Hint 2: Since the tree can have duplicate values, you need to consider the node references when finding the lowest common ancestor. You can use a recursive approach with a helper function to find the path from the root to each of the given nodes.",
      "Hint 3: When finding the lowest common ancestor, you need to consider the case where one of the given nodes is a descendant of the other. You can use a variable to store the lowest common ancestor found so far and update it as you traverse the tree."
    ]
  },
  {
    "id": 1033,
    "title": "Kth Largest Element in a Stream",
    "difficulty": "beginner",
    "category": "Heap",
    "description": "Design a class to find the kth largest element in a stream of numbers. The class should have a constructor that takes an integer k as input and a method add that takes a number as input and returns the kth largest element in the stream so far.",
    "examples": [
      {
        "input": "KthLargest kthLargest = new KthLargest(3); kthLargest.add(4); kthLargest.add(5); kthLargest.add(8); kthLargest.add(2)",
        "output": "4"
      },
      {
        "input": "KthLargest kthLargest = new KthLargest(1); kthLargest.add(1); kthLargest.add(2); kthLargest.add(3)",
        "output": "3"
      },
      {
        "input": "KthLargest kthLargest = new KthLargest(2); kthLargest.add(0); kthLargest.add(1); kthLargest.add(3); kthLargest.add(1); kthLargest.add(4)",
        "output": "1"
      }
    ],
    "starterCode": "function kthLargestElement(...args) {\n  // Your solution here\n  \n}",
    "testCases": [
      {
        "input": [
          3,
          [
            4,
            5,
            8,
            2
          ]
        ],
        "expected": 4
      },
      {
        "input": [
          1,
          [
            1,
            2,
            3
          ]
        ],
        "expected": 3
      },
      {
        "input": [
          2,
          [
            0,
            1,
            3,
            1,
            4
          ]
        ],
        "expected": 1
      },
      {
        "input": [
          3,
          []
        ],
        "expected": null
      },
      {
        "input": [
          1,
          [
            1
          ]
        ],
        "expected": 1
      }
    ],
    "functionName": "kthLargestElement",
    "hints": [
      "Hint 1: Use a data structure that can efficiently keep track of the k largest elements seen so far.",
      "Hint 2: Consider using a min-heap data structure, where the smallest element is always at the root. This can help you efficiently remove the smallest element when the heap size exceeds k.",
      "Hint 3: When adding a new element to the stream, check if the heap size is less than k. If it is, add the new element to the heap. If the heap size is already k and the new element is larger than the smallest element in the heap, remove the smallest element and add the new element."
    ]
  },
  {
    "id": 1034,
    "title": "Validating Nested Parentheses",
    "difficulty": "intermediate",
    "category": "Stack",
    "description": "Given a string containing nested parentheses, write a function to determine if the parentheses are properly nested and matched. A string of parentheses is properly nested if every open parenthesis can be matched with a corresponding close parenthesis. For example, '(())' and '()()()()' are properly nested, while '(()' and ')(' are not.",
    "examples": [
      {
        "input": "\"(())\"",
        "output": "true"
      },
      {
        "input": "\"(()\"",
        "output": "false"
      },
      {
        "input": "\"()()()()\"",
        "output": "true"
      }
    ],
    "starterCode": "function validateParentheses(s) {\n  // Your solution here\n  \n}",
    "testCases": [
      {
        "input": [
          "(())"
        ],
        "expected": true
      },
      {
        "input": [
          "(()"
        ],
        "expected": false
      },
      {
        "input": [
          "()()()()"
        ],
        "expected": true
      },
      {
        "input": [
          ")("
        ],
        "expected": false
      },
      {
        "input": [
          "("
        ],
        "expected": false
      },
      {
        "input": [
          ")"
        ],
        "expected": false
      },
      {
        "input": [
          ""
        ],
        "expected": true
      }
    ],
    "functionName": "validateParentheses",
    "hints": [
      "Hint 1: Use a data structure to keep track of the opening parentheses encountered so far.",
      "Hint 2: Consider using a stack to store the opening parentheses and match them with the corresponding closing parentheses.",
      "Hint 3: Don't forget to handle the case where there are more closing parentheses than opening ones, and also the case where there are unmatched opening parentheses at the end of the string."
    ]
  },
  {
    "id": 1035,
    "title": "minimumWindowSubstringWithKDistinctChars",
    "difficulty": "advanced",
    "category": "Strings",
    "description": "Given a string and an integer k, find the minimum window substring that contains exactly k distinct characters. If no such window exists, return an empty string.",
    "examples": [
      {
        "input": "'abcba' and 2",
        "output": "'bcb'"
      },
      {
        "input": "'aabcbc' and 3",
        "output": "'abcbc'"
      },
      {
        "input": "'aaaaaaaa' and 2",
        "output": "''"
      }
    ],
    "starterCode": "function minimumWindowSubstringWithKDistinctChars(s, k) {\n  // Your solution here\n  \n}",
    "testCases": [
      {
        "input": [
          "abcba",
          2
        ],
        "expected": "bcb"
      },
      {
        "input": [
          "aabcbc",
          3
        ],
        "expected": "abcbc"
      },
      {
        "input": [
          "aaaaaaaa",
          2
        ],
        "expected": ""
      }
    ],
    "functionName": "minimumWindowSubstringWithKDistinctChars",
    "hints": [
      "Hint 1: Consider using a sliding window approach to find the minimum window substring.",
      "Hint 2: Use a hash map to keep track of the frequency of each character in the current window.",
      "Hint 3: When the window contains more than k distinct characters, try to shrink the window from the left by moving the left pointer to the right."
    ]
  },
  {
    "id": 1036,
    "title": "Fruit Salad Mixer",
    "difficulty": "beginner",
    "category": "Hash Maps",
    "description": "Create a function that takes a list of fruit names and their corresponding quantities as input. The function should return a dictionary where the keys are the fruit names and the values are their total quantities. If a fruit is not in the dictionary, it should be added with its quantity. If a fruit is already in the dictionary, its quantity should be updated.",
    "examples": [
      {
        "input": "[['apple', 2], ['banana', 3], ['apple', 1]]",
        "output": "{'apple': 3, 'banana': 3}"
      },
      {
        "input": "[['orange', 4], ['grape', 2], ['orange', 2]]",
        "output": "{'orange': 6, 'grape': 2}"
      },
      {
        "input": "[['mango', 1], ['pineapple', 3], ['mango', 2]]",
        "output": "{'mango': 3, 'pineapple': 3}"
      }
    ],
    "starterCode": "function fruitSaladMixer(fruits) {\n  // Your solution here\n  \n}",
    "testCases": [
      {
        "input": [
          [
            [
              "apple",
              2
            ],
            [
              "banana",
              3
            ],
            [
              "apple",
              1
            ]
          ]
        ],
        "expected": {
          "apple": 3,
          "banana": 3
        }
      },
      {
        "input": [
          [
            [
              "orange",
              4
            ],
            [
              "grape",
              2
            ],
            [
              "orange",
              2
            ]
          ]
        ],
        "expected": {
          "orange": 6,
          "grape": 2
        }
      },
      {
        "input": [
          [
            [
              "mango",
              1
            ],
            [
              "pineapple",
              3
            ],
            [
              "mango",
              2
            ]
          ]
        ],
        "expected": {
          "mango": 3,
          "pineapple": 3
        }
      },
      {
        "input": [
          [
            [
              "watermelon",
              0
            ],
            [
              "strawberry",
              0
            ]
          ]
        ],
        "expected": {
          "watermelon": 0,
          "strawberry": 0
        }
      },
      {
        "input": [
          [
            [
              "kiwi",
              10
            ]
          ]
        ],
        "expected": {
          "kiwi": 10
        }
      }
    ],
    "functionName": "fruitSaladMixer",
    "hints": [
      "Hint 1: Initialize an empty dictionary to store the fruit names and their quantities.",
      "Hint 2: Iterate through the input list of fruits and quantities. For each fruit, check if it is already in the dictionary. If it is, update its quantity. If not, add it to the dictionary.",
      "Hint 3: Consider using the get method of the dictionary to handle the case where a fruit is not in the dictionary, and provide a default value of 0 for the quantity."
    ]
  },
  {
    "id": 1037,
    "title": "Valid Subsequence Checker",
    "difficulty": "intermediate",
    "category": "Stack",
    "description": "Given two sequences of integers, determine if the first sequence is a subsequence of the second sequence. A subsequence is a sequence that can be derived from another sequence by deleting some elements without changing the order of the remaining elements.",
    "examples": [
      {
        "input": "[1, 2, 3], [1, 2, 3, 4, 5]",
        "output": "true"
      },
      {
        "input": "[1, 2, 3], [1, 3, 2, 4, 5]",
        "output": "false"
      },
      {
        "input": "[1, 2, 3], [6, 7, 8, 9]",
        "output": "false"
      }
    ],
    "starterCode": "function isValidSubsequence(sequence1, sequence2) {\n  // Your solution here\n  \n}",
    "testCases": [
      {
        "input": [
          [
            1,
            2,
            3
          ],
          [
            1,
            2,
            3,
            4,
            5
          ]
        ],
        "expected": true
      },
      {
        "input": [
          [
            1,
            2,
            3
          ],
          [
            1,
            3,
            2,
            4,
            5
          ]
        ],
        "expected": false
      },
      {
        "input": [
          [
            1,
            2,
            3
          ],
          [
            6,
            7,
            8,
            9
          ]
        ],
        "expected": false
      },
      {
        "input": [
          [
            5,
            1,
            22,
            25,
            6,
            -1,
            8,
            10
          ],
          [
            1,
            6,
            -1,
            10
          ]
        ],
        "expected": true
      },
      {
        "input": [
          [
            5,
            1,
            22,
            25,
            6,
            -1,
            8,
            10
          ],
          [
            5,
            1,
            22,
            25,
            6,
            -1,
            8,
            10,
            12
          ]
        ],
        "expected": true
      }
    ],
    "functionName": "isValidSubsequence",
    "hints": [
      "Hint 1: Use two pointers to traverse the two sequences, starting from the beginning of each sequence.",
      "Hint 2: When the current elements of both sequences match, move the pointer of the first sequence forward to check the next element.",
      "Hint 3: Consider using a stack data structure to keep track of the elements in the first sequence that have been matched with the elements in the second sequence."
    ]
  },
  {
    "id": 1039,
    "title": "Find Connected Friends",
    "difficulty": "beginner",
    "category": "Graphs",
    "description": "You are given a social network represented as an adjacency list where each key is a person and the corresponding value is a list of their friends. Write a function to find all people that are directly or indirectly connected to a given person.",
    "examples": [
      {
        "input": "friends = {'Alice': ['Bob', 'Charlie'], 'Bob': ['Alice', 'David'], 'Charlie': ['Alice', 'David'], 'David': ['Bob', 'Charlie']}",
        "output": "['Alice', 'Bob', 'Charlie', 'David']"
      },
      {
        "input": "friends = {'Eve': ['Frank'], 'Frank': ['Eve']}",
        "output": "['Eve', 'Frank']"
      },
      {
        "input": "friends = {'George': []}",
        "output": "['George']"
      }
    ],
    "starterCode": "function findConnectedFriends(friends, person) {\n  // Your solution here\n  \n}",
    "testCases": [
      {
        "input": [
          {
            "Alice": [
              "Bob",
              "Charlie"
            ],
            "Bob": [
              "Alice",
              "David"
            ],
            "Charlie": [
              "Alice",
              "David"
            ],
            "David": [
              "Bob",
              "Charlie"
            ]
          },
          "Alice"
        ],
        "expected": [
          "Alice",
          "Bob",
          "Charlie",
          "David"
        ]
      },
      {
        "input": [
          {
            "Eve": [
              "Frank"
            ],
            "Frank": [
              "Eve"
            ]
          },
          "Eve"
        ],
        "expected": [
          "Eve",
          "Frank"
        ]
      },
      {
        "input": [
          {
            "George": []
          },
          "George"
        ],
        "expected": [
          "George"
        ]
      }
    ],
    "functionName": "findConnectedFriends",
    "hints": [
      "Hint 1: Use a graph traversal algorithm such as Depth-First Search (DFS) or Breadth-First Search (BFS) to find all connected people.",
      "Hint 2: Utilize a set data structure to keep track of visited people and avoid revisiting them.",
      "Hint 3: Be careful when handling the case where the given person does not exist in the social network."
    ]
  },
  {
    "id": 1040,
    "title": "Peak Element Indices",
    "difficulty": "intermediate",
    "category": "Arrays",
    "description": "Given a list of integers, return the indices of all peak elements. A peak element is an element which is greater than its neighbors. If the element is at the start or end of the list, it is considered a peak element if it is greater than its single neighbor.",
    "examples": [
      {
        "input": "[1, 2, 3, 1]",
        "output": "[2]"
      },
      {
        "input": "[1, 2, 1, 3, 5, 6, 4]",
        "output": "[1, 5]"
      },
      {
        "input": "[1, 3, 2, 1]",
        "output": "[1]"
      }
    ],
    "starterCode": "function findPeakElementIndices(...args) {\n  // Your solution here\n  \n}",
    "testCases": [
      {
        "input": [
          [
            1,
            2,
            3,
            1
          ]
        ],
        "expected": [
          2
        ]
      },
      {
        "input": [
          [
            1,
            2,
            1,
            3,
            5,
            6,
            4
          ]
        ],
        "expected": [
          1,
          5
        ]
      },
      {
        "input": [
          [
            1,
            3,
            2,
            1
          ]
        ],
        "expected": [
          1
        ]
      },
      {
        "input": [
          [
            5,
            4,
            3,
            2,
            1
          ]
        ],
        "expected": [
          0
        ]
      },
      {
        "input": [
          [
            1,
            2,
            3,
            4,
            5
          ]
        ],
        "expected": [
          4
        ]
      }
    ],
    "functionName": "findPeakElementIndices",
    "hints": [
      "Hint 1: Iterate over the list to compare each element with its neighbors and identify peak elements.",
      "Hint 2: Use conditional statements to handle edge cases where the peak element is at the start or end of the list.",
      "Hint 3: Store the indices of peak elements in a separate list and return this list as the result."
    ]
  },
  {
    "id": 1041,
    "title": "Lowest Common Ancestor of a Binary Tree with Virtual Nodes",
    "difficulty": "advanced",
    "category": "Trees",
    "description": "Given a binary tree and two nodes, find the lowest common ancestor (LCA) of the two nodes. The binary tree may have virtual nodes that are not part of the actual tree, but are used to make the tree complete. The virtual nodes are represented by null, and the actual nodes are represented by a unique integer value.",
    "examples": [
      {
        "input": "[3,5,1,6,2,0,8,null,null,7,4]",
        "output": "3"
      },
      {
        "input": "[1,2]",
        "output": "1"
      },
      {
        "input": "[5,3,6,2,4,null,null,1]",
        "output": "3"
      }
    ],
    "starterCode": "function findLowestCommonAncestor(...args) {\n  // Your solution here\n  \n}",
    "testCases": [
      {
        "input": [
          [
            3,
            5,
            1,
            6,
            2,
            0,
            8,
            null,
            null,
            7,
            4
          ],
          5,
          1
        ],
        "expected": 3
      },
      {
        "input": [
          [
            1,
            2
          ],
          1,
          2
        ],
        "expected": 1
      },
      {
        "input": [
          [
            5,
            3,
            6,
            2,
            4,
            null,
            null,
            1
          ],
          2,
          4
        ],
        "expected": 3
      }
    ],
    "functionName": "findLowestCommonAncestor",
    "hints": [
      "Hint 1: Use a recursive approach to traverse the tree and find the LCA. Consider the base cases where one or both of the nodes are not present in the tree.",
      "Hint 2: Use a helper function to find the path from the root to each of the given nodes. Then, compare the paths to find the LCA.",
      "Hint 3: When comparing the paths, consider the case where one path is a prefix of the other. In this case, the LCA is the last node in the prefix path."
    ]
  },
  {
    "id": 1042,
    "title": "Coin Collector",
    "difficulty": "beginner",
    "category": "Dynamic Programming",
    "description": "A collector has a set of coins with different denominations and wants to know the minimum number of coins needed to make a certain amount of change. The collector can use each coin denomination any number of times.",
    "examples": [
      {
        "input": "coins = [1, 2, 5], amount = 11",
        "output": "3"
      },
      {
        "input": "coins = [2], amount = 3",
        "output": "-1"
      },
      {
        "input": "coins = [1], amount = 0",
        "output": "0"
      }
    ],
    "starterCode": "function coinCollector(coins, amount) {\n  // Your solution here\n  \n}",
    "testCases": [
      {
        "input": [
          [
            1,
            2,
            5
          ],
          11
        ],
        "expected": 3
      },
      {
        "input": [
          [
            2
          ],
          3
        ],
        "expected": -1
      },
      {
        "input": [
          [
            1
          ],
          0
        ],
        "expected": 0
      },
      {
        "input": [
          [
            1,
            4,
            5
          ],
          6
        ],
        "expected": 2
      },
      {
        "input": [
          [
            1,
            2,
            5
          ],
          0
        ],
        "expected": 0
      }
    ],
    "functionName": "coinCollector",
    "hints": [
      "Hint 1: Break down the problem into smaller sub-problems by trying to make the change for each amount from 1 to the target amount.",
      "Hint 2: Use an array to store the minimum number of coins needed for each amount, and fill it up iteratively using the available coin denominations.",
      "Hint 3: If it's not possible to make the change for a certain amount, mark it as -1 in the array to avoid revisiting it later."
    ]
  },
  {
    "id": 1043,
    "title": "stringReversalChecker",
    "difficulty": "intermediate",
    "category": "Strings",
    "description": "Write a function that checks if a given string is a reversal of another string. The function should take two strings as input and return true if the first string is a reversal of the second string, and false otherwise.",
    "examples": [
      {
        "input": "'hello', 'olleh'",
        "output": "true"
      },
      {
        "input": "'abc', 'def'",
        "output": "false"
      },
      {
        "input": "'a', 'a'",
        "output": "true"
      }
    ],
    "starterCode": "function stringReversalChecker(str1, str2) {\n  // Your solution here\n  \n}",
    "testCases": [
      {
        "input": [
          "hello",
          "olleh"
        ],
        "expected": true
      },
      {
        "input": [
          "abc",
          "def"
        ],
        "expected": false
      },
      {
        "input": [
          "a",
          "a"
        ],
        "expected": true
      },
      {
        "input": [
          "",
          ""
        ],
        "expected": true
      },
      {
        "input": [
          "hello",
          ""
        ],
        "expected": false
      }
    ],
    "functionName": "stringReversalChecker",
    "hints": [
      "Hint 1: Compare the lengths of the two strings. If they are not equal, the first string cannot be a reversal of the second string.",
      "Hint 2: Consider using JavaScript's built-in string methods to reverse the second string, and then compare it to the first string.",
      "Hint 3: Take into account the case where one or both of the strings are empty. How should the function handle these edge cases?"
    ]
  },
  {
    "id": 1044,
    "title": "Minimum String Rotation",
    "difficulty": "advanced",
    "category": "Strings",
    "description": "Given a string, find the minimum number of rotations required to obtain a string that is lexicographically smaller than the original string. A rotation is defined as moving the last character to the front of the string.",
    "examples": [
      {
        "input": "abc",
        "output": 2
      },
      {
        "input": "bca",
        "output": 1
      },
      {
        "input": "cba",
        "output": 0
      }
    ],
    "starterCode": "function minimumRotations(...args) {\n  // Your solution here\n  \n}",
    "testCases": [
      {
        "input": [
          "abc"
        ],
        "expected": 2
      },
      {
        "input": [
          "bca"
        ],
        "expected": 1
      },
      {
        "input": [
          "cba"
        ],
        "expected": 0
      },
      {
        "input": [
          "aaaa"
        ],
        "expected": 0
      },
      {
        "input": [
          "abba"
        ],
        "expected": 2
      }
    ],
    "functionName": "minimumRotations",
    "hints": [
      "Hint 1: Consider generating all possible rotations of the input string and comparing them lexicographically.",
      "Hint 2: You can use a data structure like a queue or a circular buffer to efficiently generate all rotations.",
      "Hint 3: Be sure to handle edge cases, such as when the input string is already the lexicographically smallest possible rotation, or when the input string has duplicate characters."
    ]
  },
  {
    "id": 1045,
    "title": "Kth Largest Element Finder",
    "difficulty": "beginner",
    "category": "Heap",
    "description": "Create a function that finds the kth largest element in an unsorted array of integers. The function should take in an array of integers and an integer k as input, and return the kth largest element. If k is larger than the length of the array, return null.",
    "examples": [
      {
        "input": "[3, 2, 1, 5, 6, 4], 2",
        "output": "5"
      },
      {
        "input": "[10, 20, 30, 40, 50], 1",
        "output": "50"
      },
      {
        "input": "[1, 2, 3, 4, 5], 6",
        "output": "null"
      }
    ],
    "starterCode": "function findKthLargest(...args) {\n  // Your solution here\n  \n}",
    "testCases": [
      {
        "input": [
          [
            3,
            2,
            1,
            5,
            6,
            4
          ],
          2
        ],
        "expected": 5
      },
      {
        "input": [
          [
            10,
            20,
            30,
            40,
            50
          ],
          1
        ],
        "expected": 50
      },
      {
        "input": [
          [
            1,
            2,
            3,
            4,
            5
          ],
          6
        ],
        "expected": null
      },
      {
        "input": [
          [
            5,
            5,
            5,
            5,
            5
          ],
          1
        ],
        "expected": 5
      },
      {
        "input": [
          [
            1
          ],
          1
        ],
        "expected": 1
      }
    ],
    "functionName": "findKthLargest",
    "hints": [
      "Hint 1: Consider using a data structure that can efficiently find the maximum or minimum element in a collection.",
      "Hint 2: A heap data structure can be used to solve this problem. Think about how you can use a heap to find the kth largest element.",
      "Hint 3: If k is larger than the length of the array, you should return null. Consider adding a check at the beginning of your function to handle this edge case."
    ]
  },
  {
    "id": 1046,
    "title": "Find Peak Element in Mountain Array",
    "difficulty": "intermediate",
    "category": "Binary Search",
    "description": "Given a mountain array, find the index of the peak element. A mountain array is defined as an array that increases monotonically to a peak element, then decreases monotonically to the end of the array. The peak element is the element which is not smaller than its neighbors.",
    "examples": [
      {
        "input": "[0,1,2,3,4,5,4,3,2,1]",
        "output": "5"
      },
      {
        "input": "[0,2,4,6,8,10,8,6,4,2]",
        "output": "5"
      },
      {
        "input": "[1,2,3,4,5]",
        "output": "4"
      }
    ],
    "starterCode": "function findPeakElement(arr) {\n  // Your solution here\n  \n}",
    "testCases": [
      {
        "input": [
          [
            0,
            1,
            2,
            3,
            4,
            5,
            4,
            3,
            2,
            1
          ]
        ],
        "expected": 5
      },
      {
        "input": [
          [
            0,
            2,
            4,
            6,
            8,
            10,
            8,
            6,
            4,
            2
          ]
        ],
        "expected": 5
      },
      {
        "input": [
          [
            1,
            2,
            3,
            4,
            5
          ]
        ],
        "expected": 4
      },
      {
        "input": [
          [
            5,
            4,
            3,
            2,
            1
          ]
        ],
        "expected": 0
      },
      {
        "input": [
          [
            1,
            3,
            20,
            4,
            1,
            0
          ]
        ],
        "expected": 2
      }
    ],
    "functionName": "findPeakElement",
    "hints": [
      "Hint 1: Use a binary search approach to find the peak element in the mountain array, as the array is monotonically increasing and then decreasing.",
      "Hint 2: Check the middle element of the array and compare it with its neighbors. If the middle element is greater than its neighbors, it is the peak element. Otherwise, determine which half of the array to continue searching.",
      "Hint 3: Consider the edge cases where the peak element is at the beginning or end of the array, and ensure the binary search approach handles these cases correctly."
    ]
  },
  {
    "id": 1047,
    "title": "Maximum Queue Size Tracker",
    "difficulty": "advanced",
    "category": "Queue",
    "description": "Design a queue that can track the maximum size it has ever reached. The queue should support the standard enqueue and dequeue operations, as well as a getMaxSize method that returns the maximum size the queue has ever been. The queue should also support a reset method that clears the queue and resets the maximum size tracker.",
    "examples": [
      {
        "input": "enqueue(1), enqueue(2), dequeue(), getMaxSize()",
        "output": "2"
      },
      {
        "input": "enqueue(1), enqueue(2), enqueue(3), dequeue(), getMaxSize()",
        "output": "3"
      },
      {
        "input": "enqueue(1), dequeue(), enqueue(2), getMaxSize()",
        "output": "1"
      }
    ],
    "starterCode": "function maxQueueSizeTracker(...args) {\n  // Your solution here\n  \n}",
    "testCases": [
      {
        "input": [
          [
            "enqueue",
            1
          ],
          [
            "enqueue",
            2
          ],
          [
            "dequeue"
          ],
          [
            "getMaxSize"
          ]
        ],
        "expected": 2
      },
      {
        "input": [
          [
            "enqueue",
            1
          ],
          [
            "enqueue",
            2
          ],
          [
            "enqueue",
            3
          ],
          [
            "dequeue"
          ],
          [
            "getMaxSize"
          ]
        ],
        "expected": 3
      },
      {
        "input": [
          [
            "enqueue",
            1
          ],
          [
            "dequeue"
          ],
          [
            "enqueue",
            2
          ],
          [
            "getMaxSize"
          ]
        ],
        "expected": 1
      },
      {
        "input": [
          [
            "enqueue",
            1
          ],
          [
            "enqueue",
            2
          ],
          [
            "reset"
          ],
          [
            "getMaxSize"
          ]
        ],
        "expected": 0
      },
      {
        "input": [
          [
            "enqueue",
            1
          ],
          [
            "dequeue"
          ],
          [
            "reset"
          ],
          [
            "getMaxSize"
          ]
        ],
        "expected": 0
      }
    ],
    "functionName": "maxQueueSizeTracker",
    "hints": [
      "Hint 1: Use a combination of a queue data structure and a variable to keep track of the maximum size.",
      "Hint 2: Consider using a class-based approach to encapsulate the queue and the maximum size tracker, and provide methods for enqueue, dequeue, getMaxSize, and reset.",
      "Hint 3: When implementing the reset method, make sure to clear the queue and reset the maximum size tracker to its initial state."
    ]
  },
  {
    "id": 1048,
    "title": "Fractional Part",
    "difficulty": "beginner",
    "category": "Math",
    "description": "Write a function to calculate the fractional part of a given number. The fractional part is the decimal part of the number, which is the part after the decimal point.",
    "examples": [
      {
        "input": "10.5",
        "output": "0.5"
      },
      {
        "input": "12",
        "output": "0"
      },
      {
        "input": "-3.7",
        "output": "0.7"
      }
    ],
    "starterCode": "function fractionalPart(...args) {\n  // Your solution here\n  \n}",
    "testCases": [
      {
        "input": [
          10.5
        ],
        "expected": 0.5
      },
      {
        "input": [
          12
        ],
        "expected": 0
      },
      {
        "input": [
          -3.7
        ],
        "expected": 0.7
      },
      {
        "input": [
          0
        ],
        "expected": 0
      },
      {
        "input": [
          3.14159
        ],
        "expected": 0.14159
      }
    ],
    "functionName": "fractionalPart",
    "hints": [
      "Hint 1: You can use basic arithmetic operations to isolate the fractional part of a number.",
      "Hint 2: Consider using the absolute value of the number to simplify the calculation.",
      "Hint 3: Think about how you can use subtraction to separate the integer and fractional parts of the number."
    ]
  },
  {
    "id": 1049,
    "title": "Partition Array to Meet Maximum Sum",
    "difficulty": "intermediate",
    "category": "Dynamic Programming",
    "description": "Given an array of integers and a target sum, partition the array into the fewest number of subarrays such that the sum of each subarray does not exceed the target sum. Return the minimum number of subarrays required.",
    "examples": [
      {
        "input": "[1, 2, 3, 4, 5], 7",
        "output": "3"
      },
      {
        "input": "[5, 5, 5], 10",
        "output": "3"
      },
      {
        "input": "[1, 1, 1, 1, 1], 5",
        "output": "1"
      }
    ],
    "starterCode": "function partitionArray(...args) {\n  // Your solution here\n  \n}",
    "testCases": [
      {
        "input": [
          [
            1,
            2,
            3,
            4,
            5
          ],
          7
        ],
        "expected": 3
      },
      {
        "input": [
          [
            5,
            5,
            5
          ],
          10
        ],
        "expected": 3
      },
      {
        "input": [
          [
            1,
            1,
            1,
            1,
            1
          ],
          5
        ],
        "expected": 1
      },
      {
        "input": [
          [
            10,
            10,
            10
          ],
          20
        ],
        "expected": 3
      },
      {
        "input": [
          [
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1
          ],
          10
        ],
        "expected": 1
      }
    ],
    "functionName": "partitionArray",
    "hints": [
      "Hint 1: This problem can be solved by using dynamic programming to keep track of the minimum number of subarrays required up to each index in the array.",
      "Hint 2: Use a 2D array to store the minimum number of subarrays required for each subarray ending at each index, and iterate through the array to fill up this 2D array.",
      "Hint 3: When filling up the 2D array, for each index, try to extend the subarray from all previous indices and update the minimum number of subarrays required if the sum of the extended subarray does not exceed the target sum."
    ]
  },
  {
    "id": 1050,
    "title": "Generating Valid IP Addresses",
    "difficulty": "advanced",
    "category": "Backtracking",
    "description": "Given a string of digits, generate all possible valid IP addresses that can be formed from the string. An IP address is valid if it consists of four parts separated by dots, and each part is a number between 0 and 255 (inclusive) with no leading zeros, unless the number is 0.",
    "examples": [
      {
        "input": "\"25525511135\"",
        "output": "[\"255.255.11.135\", \"255.255.111.35\"]"
      },
      {
        "input": "\"0000\"",
        "output": "[\"0.0.0.0\"]"
      },
      {
        "input": "\"101023\"",
        "output": "[\"1.0.10.23\", \"1.0.102.3\", \"10.1.0.23\", \"10.10.2.3\", \"101.0.2.3\"]"
      }
    ],
    "starterCode": "function restoreIpAddresses(...args) {\n  // Your solution here\n  \n}",
    "testCases": [
      {
        "input": [
          "25525511135"
        ],
        "expected": [
          "255.255.11.135",
          "255.255.111.35"
        ]
      },
      {
        "input": [
          "0000"
        ],
        "expected": [
          "0.0.0.0"
        ]
      },
      {
        "input": [
          "101023"
        ],
        "expected": [
          "1.0.10.23",
          "1.0.102.3",
          "10.1.0.23",
          "10.10.2.3",
          "101.0.2.3"
        ]
      },
      {
        "input": [
          "1111"
        ],
        "expected": [
          "1.1.1.1"
        ]
      },
      {
        "input": [
          "1234567"
        ],
        "expected": [
          "1.2.3.4567",
          "1.2.34.567",
          "1.2.345.67",
          "1.23.4.567",
          "1.23.45.67",
          "1.234.5.67",
          "12.3.4.567",
          "12.3.45.67",
          "12.34.5.67",
          "123.4.5.67"
        ]
      }
    ],
    "functionName": "restoreIpAddresses",
    "hints": [
      "Consider using backtracking to generate all possible IP addresses, as the number of possible addresses can be quite large.",
      "You can use a recursive function to generate the IP addresses. In each recursive call, try to add the next part of the IP address to the current address.",
      "To avoid generating invalid IP addresses, make sure to check if the current part of the address is a valid number (i.e., between 0 and 255 with no leading zeros). Also, be careful not to exceed the length of the input string."
    ]
  },
  {
    "id": 1051,
    "title": "Peak Element Finder",
    "difficulty": "beginner",
    "category": "Arrays",
    "description": "Given an array of integers, write a function to find the index of the peak element, which is the element that is greater than its neighbors. If there are multiple peak elements, return the index of the first one. If the array is empty, return -1.",
    "examples": [
      {
        "input": "[1, 2, 3, 1]",
        "output": "2"
      },
      {
        "input": "[1, 2, 1, 3, 5, 6, 4]",
        "output": "5"
      },
      {
        "input": "[]",
        "output": "-1"
      }
    ],
    "starterCode": "function findPeakElement(...args) {\n  // Your solution here\n  \n}",
    "testCases": [
      {
        "input": [
          [
            1,
            2,
            3,
            1
          ]
        ],
        "expected": 2
      },
      {
        "input": [
          [
            1,
            2,
            1,
            3,
            5,
            6,
            4
          ]
        ],
        "expected": 5
      },
      {
        "input": [
          []
        ],
        "expected": -1
      },
      {
        "input": [
          [
            1
          ]
        ],
        "expected": 0
      },
      {
        "input": [
          [
            1,
            2
          ]
        ],
        "expected": 1
      }
    ],
    "functionName": "findPeakElement",
    "hints": [
      "Hint 1: Start by checking if the array is empty. If it is, return -1 as per the problem statement.",
      "Hint 2: Consider iterating through the array, checking each element to see if it's greater than its neighbors. You can use a simple conditional statement to check this.",
      "Hint 3: Think about what happens if the peak element is at the start or end of the array. How will you handle these edge cases?"
    ]
  },
  {
    "id": 1052,
    "title": "Bitwise Substring Extraction",
    "difficulty": "intermediate",
    "category": "Bit Manipulation",
    "description": "Given a binary string and a range defined by two integers, extract the substring of bits within the given range and return it as an integer. The range is 1-indexed and inclusive. For example, given the binary string '101101' and the range [2, 4], the extracted substring is '011' which is equivalent to the integer 3.",
    "examples": [
      {
        "input": "'101101', [2, 4]",
        "output": "3"
      },
      {
        "input": "'1101', [1, 3]",
        "output": "6"
      },
      {
        "input": "'10000', [1, 5]",
        "output": "16"
      }
    ],
    "starterCode": "function extractBits(...args) {\n  // Your solution here\n  \n}",
    "testCases": [
      {
        "input": [
          "101101",
          [
            2,
            4
          ]
        ],
        "expected": 3
      },
      {
        "input": [
          "1101",
          [
            1,
            3
          ]
        ],
        "expected": 6
      },
      {
        "input": [
          "10000",
          [
            1,
            5
          ]
        ],
        "expected": 16
      },
      {
        "input": [
          "1",
          [
            1,
            1
          ]
        ],
        "expected": 1
      },
      {
        "input": [
          "0",
          [
            1,
            1
          ]
        ],
        "expected": 0
      }
    ],
    "functionName": "extractBits",
    "hints": [
      "Hint 1: Convert the binary string to an integer to simplify the extraction process.",
      "Hint 2: Use bitwise shift operators to remove bits outside the desired range.",
      "Hint 3: Consider using a bitmask to extract the desired substring of bits."
    ]
  },
  {
    "id": 1055,
    "title": "Minimum Cost to Climb Stairs with Variable Step Size",
    "difficulty": "intermediate",
    "category": "Dynamic Programming",
    "description": "You are given an array of integers representing the cost to climb each step of a staircase. The staircase has n steps, and you can climb either 1 or 2 steps at a time. Determine the minimum cost to reach the top step, considering that you can start climbing from the first step.",
    "examples": [
      {
        "input": "[1, 2, 3, 4]",
        "output": "6"
      },
      {
        "input": "[10, 15, 20]",
        "output": "15"
      },
      {
        "input": "[1, 100, 1, 1, 1, 100, 1, 1, 100, 1]",
        "output": "6"
      }
    ],
    "starterCode": "function minCostToClimbStairs(cost) {\n  // Your solution here\n  \n}",
    "testCases": [
      {
        "input": [
          [
            1,
            2,
            3,
            4
          ]
        ],
        "expected": 6
      },
      {
        "input": [
          [
            10,
            15,
            20
          ]
        ],
        "expected": 15
      },
      {
        "input": [
          [
            1,
            100,
            1,
            1,
            1,
            100,
            1,
            1,
            100,
            1
          ]
        ],
        "expected": 6
      },
      {
        "input": [
          [
            0,
            0,
            0,
            0
          ]
        ],
        "expected": 0
      },
      {
        "input": [
          [
            10
          ]
        ],
        "expected": 10
      },
      {
        "input": [
          [
            10,
            10
          ]
        ],
        "expected": 10
      }
    ],
    "functionName": "minCostToClimbStairs",
    "hints": [
      "Hint 1: Break down the problem into smaller sub-problems and consider using a bottom-up dynamic programming approach.",
      "Hint 2: Create an array to store the minimum cost to reach each step. Consider the minimum cost to reach the previous step and the step before that when calculating the minimum cost to reach the current step.",
      "Hint 3: Handle the base cases carefully, such as when there is only one step or two steps in the staircase. Consider using a loop to fill up the array of minimum costs from the first step to the top step."
    ]
  },
  {
    "id": 1056,
    "title": "Lowest Common Ancestor in a Binary Tree with Virtual Nodes",
    "difficulty": "advanced",
    "category": "Trees",
    "description": "Given a binary tree where each node has a unique integer value, and two virtual nodes with values p and q, find the lowest common ancestor (LCA) of p and q. The LCA is the node farthest from the root that is an ancestor of both p and q. If p or q is not found in the tree, return null. If p and q are the same node, return that node. The tree is not guaranteed to be balanced, and the virtual nodes p and q may not exist in the tree.",
    "examples": [
      {
        "input": "root = [3, 5, 1, 6, 2, 0, 8, null, null, 7, 4], p = 5, q = 1",
        "output": "3"
      },
      {
        "input": "root = [3, 5, 1, 6, 2, 0, 8, null, null, 7, 4], p = 5, q = 4",
        "output": "5"
      },
      {
        "input": "root = [3, 5, 1, 6, 2, 0, 8, null, null, 7, 4], p = 3, q = 3",
        "output": "3"
      }
    ],
    "starterCode": "function findLowestCommonAncestor(...args) {\n  // Your solution here\n  \n}",
    "testCases": [
      {
        "input": [
          [
            3,
            5,
            1,
            6,
            2,
            0,
            8,
            null,
            null,
            7,
            4
          ],
          5,
          1
        ],
        "expected": 3
      },
      {
        "input": [
          [
            3,
            5,
            1,
            6,
            2,
            0,
            8,
            null,
            null,
            7,
            4
          ],
          5,
          4
        ],
        "expected": 5
      },
      {
        "input": [
          [
            3,
            5,
            1,
            6,
            2,
            0,
            8,
            null,
            null,
            7,
            4
          ],
          3,
          3
        ],
        "expected": 3
      }
    ],
    "functionName": "findLowestCommonAncestor",
    "hints": [
      "Hint 1: Traverse the binary tree to find the paths from the root to p and q, and then compare these paths to find the LCA.",
      "Hint 2: Utilize a recursive approach to traverse the tree, considering the base case where the current node is null or equals p or q.",
      "Hint 3: When comparing the paths, consider the case where p or q may not exist in the tree, and return null accordingly."
    ]
  },
  {
    "id": 1057,
    "title": "Friendship Circle",
    "difficulty": "beginner",
    "category": "Graphs",
    "description": "Given a list of friendships between people, determine the size of the largest social circle. A social circle is a group of people where everyone knows each other. The input is a list of pairs of people who are friends, and the output is the size of the largest social circle.",
    "examples": [
      {
        "input": "[[1, 2], [2, 3], [3, 1], [4, 5]]",
        "output": "3"
      },
      {
        "input": "[[1, 2], [2, 3], [3, 4], [4, 1]]",
        "output": "4"
      },
      {
        "input": "[[1, 2], [3, 4], [5, 6]]",
        "output": "2"
      }
    ],
    "starterCode": "function findLargestSocialCircle(friendships) {\n  // Your solution here\n  \n}",
    "testCases": [
      {
        "input": [
          [
            1,
            2
          ],
          [
            2,
            3
          ],
          [
            3,
            1
          ],
          [
            4,
            5
          ]
        ],
        "expected": 3
      },
      {
        "input": [
          [
            1,
            2
          ],
          [
            2,
            3
          ],
          [
            3,
            4
          ],
          [
            4,
            1
          ]
        ],
        "expected": 4
      },
      {
        "input": [
          [
            1,
            2
          ],
          [
            3,
            4
          ],
          [
            5,
            6
          ]
        ],
        "expected": 2
      }
    ],
    "functionName": "findLargestSocialCircle",
    "hints": [
      "Hint 1: Represent the friendships as a graph, where each person is a node and each friendship is an edge between two nodes.",
      "Hint 2: Use a depth-first search (DFS) algorithm to traverse the graph and find connected components, which represent the social circles.",
      "Hint 3: Keep track of the size of each social circle by counting the number of nodes visited during the DFS traversal, and update the maximum size found so far."
    ]
  },
  {
    "id": 1060,
    "title": "Coin Change Variations",
    "difficulty": "beginner",
    "category": "Dynamic Programming",
    "description": "Given a set of coin denominations and a total amount, find the number of ways to make change for the given amount using the available coin denominations. You can use each coin denomination any number of times.",
    "examples": [
      {
        "input": "[1, 2, 5], 5",
        "output": "4"
      },
      {
        "input": "[2], 3",
        "output": "0"
      },
      {
        "input": "[1, 2, 5], 0",
        "output": "1"
      }
    ],
    "starterCode": "function coinChangeVariations(coins, amount) {\n  // Your solution here\n  \n}",
    "testCases": [
      {
        "input": [
          [
            1,
            2,
            5
          ],
          5
        ],
        "expected": 4
      },
      {
        "input": [
          [
            2
          ],
          3
        ],
        "expected": 0
      },
      {
        "input": [
          [
            1,
            2,
            5
          ],
          0
        ],
        "expected": 1
      },
      {
        "input": [
          [
            1
          ],
          10
        ],
        "expected": 1
      },
      {
        "input": [
          [
            5,
            10,
            25
          ],
          37
        ],
        "expected": 4
      }
    ],
    "functionName": "coinChangeVariations",
    "hints": [
      "Hint 1: Break down the problem into smaller sub-problems by considering each coin denomination one at a time.",
      "Hint 2: Use a dynamic programming table to store the number of ways to make change for each amount from 0 to the given amount.",
      "Hint 3: When filling in the dynamic programming table, consider whether the current coin denomination is less than or equal to the current amount, and update the table accordingly."
    ]
  },
  {
    "id": 1061,
    "title": "Find Common Characters in Strings",
    "difficulty": "intermediate",
    "category": "Hash Maps",
    "description": "Given an array of strings, find the common characters among all the strings and return them as an array of strings, where each string appears as many times as it appears in all the input strings.",
    "examples": [
      {
        "input": "['bella', 'label', 'roller']",
        "output": "['e', 'l', 'l']"
      },
      {
        "input": "['abc', 'bcd', 'cde']",
        "output": "['c']"
      },
      {
        "input": "['abc', 'def', 'ghi']",
        "output": "[]"
      }
    ],
    "starterCode": "function findCommonCharacters(...args) {\n  // Your solution here\n  \n}",
    "testCases": [
      {
        "input": [
          "bella",
          "label",
          "roller"
        ],
        "expected": [
          "e",
          "l",
          "l"
        ]
      },
      {
        "input": [
          "abc",
          "bcd",
          "cde"
        ],
        "expected": [
          "c"
        ]
      },
      {
        "input": [
          "abc",
          "def",
          "ghi"
        ],
        "expected": []
      },
      {
        "input": [
          "a",
          "a",
          "a"
        ],
        "expected": [
          "a"
        ]
      },
      {
        "input": [
          "",
          "a",
          "b"
        ],
        "expected": []
      }
    ],
    "functionName": "findCommonCharacters",
    "hints": [
      "Hint 1: Create a hash map to store the frequency of characters in the first string, then iterate over the rest of the strings to update the frequency map.",
      "Hint 2: Use the Math.min function to find the minimum frequency of each character across all strings, and add the character to the result array that many times.",
      "Hint 3: Consider the case where a string is empty, or where a character appears zero times in all strings, to avoid errors and ensure correct output."
    ]
  },
  {
    "id": 1062,
    "title": "Validating Nested Parentheses Sequences",
    "difficulty": "advanced",
    "category": "Stack",
    "description": "Write a function to validate whether a given sequence of parentheses is valid. A sequence is valid if every open parenthesis has a corresponding close parenthesis and the pairs of parentheses are properly nested.",
    "examples": [
      {
        "input": "((()))",
        "output": "true"
      },
      {
        "input": "(()",
        "output": "false"
      },
      {
        "input": "())",
        "output": "false"
      }
    ],
    "starterCode": "function validateParentheses(...args) {\n  // Your solution here\n  \n}",
    "testCases": [
      {
        "input": [
          "((()))"
        ],
        "expected": true
      },
      {
        "input": [
          "(()"
        ],
        "expected": false
      },
      {
        "input": [
          "())"
        ],
        "expected": false
      },
      {
        "input": [
          "()()()"
        ],
        "expected": true
      },
      {
        "input": [
          ""
        ],
        "expected": true
      },
      {
        "input": [
          "("
        ],
        "expected": false
      },
      {
        "input": [
          ")"
        ],
        "expected": false
      }
    ],
    "functionName": "validateParentheses",
    "hints": [
      "Hint 1: Use a stack data structure to keep track of the opening parentheses encountered so far.",
      "Hint 2: When a closing parenthesis is encountered, check if the stack is empty or the top of the stack does not match the closing parenthesis.",
      "Hint 3: After processing the entire sequence, the stack should be empty for the sequence to be valid."
    ]
  },
  {
    "id": 1063,
    "title": "Grid Path Explorer",
    "difficulty": "beginner",
    "category": "Backtracking",
    "description": "Given a grid with dimensions MxN and a set of blocked cells, find all possible paths from the top-left cell to the bottom-right cell. A path can only be constructed by moving either right or down from a cell, and a cell can only be visited once.",
    "examples": [
      {
        "input": "[[0, 0], [[0, 1], [1, 0]]]",
        "output": "[[[0, 0], [0, 1], [1, 1]], [[0, 0], [1, 0], [1, 1]]]"
      },
      {
        "input": "[[1, 1], []]",
        "output": "[[[0, 0], [0, 1]]]"
      },
      {
        "input": "[[2, 2], [[0, 0], [1, 1]]]",
        "output": "[]"
      }
    ],
    "starterCode": "function gridPathExplorer(gridDimensions, blockedCells) {\n  // Your solution here\n  \n}",
    "testCases": [
      {
        "input": [
          [
            2,
            2
          ],
          []
        ],
        "expected": [
          [
            [
              [
                0,
                0
              ],
              [
                0,
                1
              ],
              [
                1,
                1
              ]
            ],
            [
              [
                0,
                0
              ],
              [
                1,
                0
              ],
              [
                1,
                1
              ]
            ]
          ]
        ]
      },
      {
        "input": [
          [
            3,
            3
          ],
          [
            [
              1,
              1
            ]
          ]
        ],
        "expected": [
          [
            [
              [
                0,
                0
              ],
              [
                0,
                1
              ],
              [
                0,
                2
              ],
              [
                1,
                2
              ],
              [
                2,
                2
              ]
            ],
            [
              [
                0,
                0
              ],
              [
                1,
                0
              ],
              [
                2,
                0
              ],
              [
                2,
                1
              ],
              [
                2,
                2
              ]
            ],
            [
              [
                0,
                0
              ],
              [
                0,
                1
              ],
              [
                1,
                1
              ],
              [
                1,
                2
              ],
              [
                2,
                2
              ]
            ]
          ]
        ]
      },
      {
        "input": [
          [
            1,
            1
          ],
          []
        ],
        "expected": [
          [
            [
              [
                0,
                0
              ]
            ]
          ]
        ]
      }
    ],
    "functionName": "gridPathExplorer",
    "hints": [
      "Consider using a recursive approach to explore all possible paths in the grid, backtracking when a dead end is reached.",
      "Use a set or matrix to keep track of visited cells and avoid revisiting them, reducing computation time and preventing infinite loops.",
      "Account for edge cases such as an empty grid, a grid with no blocked cells, or a grid where the start or end cell is blocked."
    ]
  },
  {
    "id": 1064,
    "title": "Merge Sorted Linked Lists with Duplicate Removal",
    "difficulty": "intermediate",
    "category": "Linked Lists",
    "description": "You are given two sorted linked lists. Merge these two lists into one sorted list while removing any duplicates and maintaining the original order of elements.",
    "examples": [
      {
        "input": "[1, 2, 3] and [2, 3, 4]",
        "output": "[1, 2, 3, 4]"
      },
      {
        "input": "[1, 3, 5] and [2, 4, 6]",
        "output": "[1, 2, 3, 4, 5, 6]"
      },
      {
        "input": "[1, 1, 1] and [1, 1, 1]",
        "output": "[1]"
      }
    ],
    "starterCode": "function mergeSortedLists(...args) {\n  // Your solution here\n  \n}",
    "testCases": [
      {
        "input": [
          [
            1,
            2,
            3
          ],
          [
            2,
            3,
            4
          ]
        ],
        "expected": [
          1,
          2,
          3,
          4
        ]
      },
      {
        "input": [
          [
            1,
            3,
            5
          ],
          [
            2,
            4,
            6
          ]
        ],
        "expected": [
          1,
          2,
          3,
          4,
          5,
          6
        ]
      },
      {
        "input": [
          [
            1,
            1,
            1
          ],
          [
            1,
            1,
            1
          ]
        ],
        "expected": [
          1
        ]
      },
      {
        "input": [
          [],
          [
            1,
            2,
            3
          ]
        ],
        "expected": [
          1,
          2,
          3
        ]
      },
      {
        "input": [
          [
            1,
            2,
            3
          ],
          []
        ],
        "expected": [
          1,
          2,
          3
        ]
      }
    ],
    "functionName": "mergeSortedLists",
    "hints": [
      "Start by understanding how to traverse and merge two linked lists. Then, consider how to remove duplicates from the merged list.",
      "A Set data structure can be used to keep track of unique elements encountered during the merge process. This will help in removing duplicates efficiently.",
      "To maintain the original order of elements, consider using a two-pointer technique to iterate through both linked lists simultaneously, comparing elements and adding the smaller one to the result list if it's not already present in the Set."
    ]
  },
  {
    "id": 1065,
    "title": "Merge K Sorted Linked Lists",
    "difficulty": "advanced",
    "category": "Linked Lists",
    "description": "Given an array of k sorted linked lists, merge them into one sorted linked list. The lists are non-empty, and each node has a unique value. The solution should have a time complexity of O(N log k), where N is the total number of nodes across all linked lists.",
    "examples": [
      {
        "input": "[[1, 2, 3], [4, 5, 6], [7, 8, 9]]",
        "output": "[1, 2, 3, 4, 5, 6, 7, 8, 9]"
      },
      {
        "input": "[[1, 3, 5], [2, 4, 6]]",
        "output": "[1, 2, 3, 4, 5, 6]"
      },
      {
        "input": "[[1], [2], [3]]",
        "output": "[1, 2, 3]"
      }
    ],
    "starterCode": "function mergeKLists(...args) {\n  // Your solution here\n  \n}",
    "testCases": [
      {
        "input": [
          [
            [
              1,
              2,
              3
            ],
            [
              4,
              5,
              6
            ],
            [
              7,
              8,
              9
            ]
          ]
        ],
        "expected": [
          1,
          2,
          3,
          4,
          5,
          6,
          7,
          8,
          9
        ]
      },
      {
        "input": [
          [
            [
              1,
              3,
              5
            ],
            [
              2,
              4,
              6
            ]
          ]
        ],
        "expected": [
          1,
          2,
          3,
          4,
          5,
          6
        ]
      },
      {
        "input": [
          [
            [
              1
            ],
            [
              2
            ],
            [
              3
            ]
          ]
        ],
        "expected": [
          1,
          2,
          3
        ]
      }
    ],
    "functionName": "mergeKLists",
    "hints": [
      "Hint 1: Consider using a priority queue to efficiently select the smallest node from the k linked lists at each step.",
      "Hint 2: Think about how you can utilize a min-heap data structure to achieve the required time complexity of O(N log k).",
      "Hint 3: When implementing the priority queue, be sure to account for the case where two nodes have the same value, and consider how to break ties to ensure the correct order in the merged linked list."
    ]
  },
  {
    "id": 1066,
    "title": "Frequent Characters",
    "difficulty": "beginner",
    "category": "Hash Maps",
    "description": "Write a function to find all characters in a string that appear with a frequency greater than or equal to half the length of the string.",
    "examples": [
      {
        "input": "\"abcde\"",
        "output": "[]"
      },
      {
        "input": "\"aaaaa\"",
        "output": "[\"a\"]"
      },
      {
        "input": "\"ababa\"",
        "output": "[\"a\", \"b\"]"
      }
    ],
    "starterCode": "function frequentChars(str) {\n  // Your solution here\n  \n}",
    "testCases": [
      {
        "input": [
          "abcde"
        ],
        "expected": []
      },
      {
        "input": [
          "aaaaa"
        ],
        "expected": [
          "a"
        ]
      },
      {
        "input": [
          "ababa"
        ],
        "expected": [
          "a",
          "b"
        ]
      },
      {
        "input": [
          "abcabc"
        ],
        "expected": [
          "a",
          "b",
          "c"
        ]
      },
      {
        "input": [
          ""
        ],
        "expected": []
      }
    ],
    "functionName": "frequentChars",
    "hints": [
      "Hint 1: First, count the frequency of each character in the string. This can be done by iterating over the string and keeping track of the counts.",
      "Hint 2: Consider using a hash map (or an object in JavaScript) to store the character frequencies, where the keys are the characters and the values are their frequencies.",
      "Hint 3: Once you have the character frequencies, iterate over the hash map and check if each character's frequency is greater than or equal to half the length of the string. If it is, add the character to the result array."
    ]
  },
  {
    "id": 1067,
    "title": "Find Lowest Common Ancestor in a Binary Tree with Given Nodes",
    "difficulty": "intermediate",
    "category": "Trees",
    "description": "Given a binary tree and two nodes, find the lowest common ancestor of the two nodes. The lowest common ancestor is the node that is farthest from the root and is an ancestor of both nodes.",
    "examples": [
      {
        "input": "root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1",
        "output": "3"
      },
      {
        "input": "root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4",
        "output": "5"
      },
      {
        "input": "root = [1,2], p = 1, q = 2",
        "output": "1"
      }
    ],
    "starterCode": "function findLowestCommonAncestor(root, p, q) {\n  // Your solution here\n  \n}",
    "testCases": [
      {
        "input": [
          [
            3,
            5,
            1,
            6,
            2,
            0,
            8,
            null,
            null,
            7,
            4
          ],
          5,
          1
        ],
        "expected": 3
      },
      {
        "input": [
          [
            3,
            5,
            1,
            6,
            2,
            0,
            8,
            null,
            null,
            7,
            4
          ],
          5,
          4
        ],
        "expected": 5
      },
      {
        "input": [
          [
            1,
            2
          ],
          1,
          2
        ],
        "expected": 1
      }
    ],
    "functionName": "findLowestCommonAncestor",
    "hints": [
      "Hint 1: Use a recursive approach to traverse the binary tree and find the lowest common ancestor.",
      "Hint 2: Use a helper function to find the path from the root to each of the given nodes, and then compare the paths to find the lowest common ancestor.",
      "Hint 3: Handle the case where one of the given nodes is the root of the tree, and the case where the lowest common ancestor is one of the given nodes."
    ]
  },
  {
    "id": 1068,
    "title": "Find the Peak Element in a 2D Array",
    "difficulty": "advanced",
    "category": "Binary Search",
    "description": "Given a 2D array with distinct elements, find the peak element. A peak element is an element which is greater than or equal to its neighbors. The neighbors of an element at position (i, j) are the elements at positions (i-1, j), (i+1, j), (i, j-1), and (i, j+1). If the element is at the edge of the array, it only has two or three neighbors. If there are multiple peak elements, return any one of them. The input array will not be empty and will have at least one peak element.",
    "examples": [
      {
        "input": "[[1, 2, 3], [4, 5, 6], [7, 8, 9]]",
        "output": "9"
      },
      {
        "input": "[[1, 3, 2], [4, 7, 6], [7, 5, 9]]",
        "output": "9"
      },
      {
        "input": "[[10, 20, 30], [40, 50, 60], [70, 80, 90]]",
        "output": "90"
      }
    ],
    "starterCode": "function findPeakElement(arr) {\n  // Your solution here\n  \n}",
    "testCases": [
      {
        "input": [
          [
            [
              1,
              2,
              3
            ],
            [
              4,
              5,
              6
            ],
            [
              7,
              8,
              9
            ]
          ]
        ],
        "expected": 9
      },
      {
        "input": [
          [
            [
              1,
              3,
              2
            ],
            [
              4,
              7,
              6
            ],
            [
              7,
              5,
              9
            ]
          ]
        ],
        "expected": 9
      },
      {
        "input": [
          [
            [
              10,
              20,
              30
            ],
            [
              40,
              50,
              60
            ],
            [
              70,
              80,
              90
            ]
          ]
        ],
        "expected": 90
      },
      {
        "input": [
          [
            [
              5
            ]
          ]
        ],
        "expected": 5
      },
      {
        "input": [
          [
            [
              1,
              2
            ],
            [
              3,
              4
            ]
          ]
        ],
        "expected": 4
      }
    ],
    "functionName": "findPeakElement",
    "hints": [
      "Hint 1: Start by understanding the properties of a peak element in a 2D array. Consider how you can use this information to narrow down the search space.",
      "Hint 2: A binary search approach can be used to find the peak element. Think about how you can use the properties of the peak element to guide the search.",
      "Hint 3: When implementing the binary search, consider how you can use the middle element of the current search space to determine which half of the space to continue searching in. Be careful to handle edge cases, such as when the middle element is on the edge of the array."
    ]
  },
  {
    "id": 1071,
    "title": "Minimum Cost to Paint Houses",
    "difficulty": "advanced",
    "category": "Dynamic Programming",
    "description": "There are a row of houses, each house can be painted with one of the three colors: red, blue and green. The cost of painting each house with a certain color is different. You have to paint all the houses such that no two adjacent houses have the same color. The cost of painting each house with a certain color is given by a 2D array where the number of rows represents the number of houses and the number of columns represents the number of colors. Find the minimum cost to paint all houses.",
    "examples": [
      {
        "input": "[[17,2,17],[16,16,5],[14,3,19]]",
        "output": "10"
      },
      {
        "input": "[[7,3,8],[6,4,8],[10,5,2]]",
        "output": "12"
      },
      {
        "input": "[[1,5,3],[2,9,1]]",
        "output": "4"
      }
    ],
    "starterCode": "function minCostToPaintHouses(cost) {\n  // Your solution here\n  \n}",
    "testCases": [
      {
        "input": [
          [
            17,
            2,
            17
          ],
          [
            16,
            16,
            5
          ],
          [
            14,
            3,
            19
          ]
        ],
        "expected": 10
      },
      {
        "input": [
          [
            7,
            3,
            8
          ],
          [
            6,
            4,
            8
          ],
          [
            10,
            5,
            2
          ]
        ],
        "expected": 12
      },
      {
        "input": [
          [
            1,
            5,
            3
          ],
          [
            2,
            9,
            1
          ]
        ],
        "expected": 4
      },
      {
        "input": [
          [
            5,
            4,
            2
          ],
          [
            3,
            4,
            5
          ],
          [
            1,
            2,
            3
          ]
        ],
        "expected": 8
      },
      {
        "input": [
          [
            1,
            2,
            3
          ],
          [
            4,
            5,
            6
          ],
          [
            7,
            8,
            9
          ]
        ],
        "expected": 12
      }
    ],
    "functionName": "minCostToPaintHouses",
    "hints": [
      "Hint 1: Use dynamic programming to track the minimum cost for each house and each color.",
      "Hint 2: Create a 2D DP table where dp[i][j] represents the minimum cost to paint the first i houses and the last house is painted with color j.",
      "Hint 3: To fill up the DP table, iterate through each house and each color, and for each house, calculate the minimum cost by considering the minimum cost of the previous house with a different color."
    ]
  },
  {
    "id": 1073,
    "title": "findLongestCommonSubsequence",
    "difficulty": "intermediate",
    "category": "Strings",
    "description": "Given two strings, find the length of the longest common subsequence between them. A subsequence is a sequence that can be derived from another sequence by deleting some elements without changing the order of the remaining elements.",
    "examples": [
      {
        "input": "\"ABCBDAB\" and \"BDCABA\"",
        "output": "4"
      },
      {
        "input": "\"ABCDEFG\" and \"GFEDCBA\"",
        "output": "4"
      },
      {
        "input": "\"ABC\" and \"DEF\"",
        "output": "0"
      }
    ],
    "starterCode": "function findLongestCommonSubsequence(str1, str2) {\n  // Your solution here\n  \n}",
    "testCases": [
      {
        "input": [
          "ABCBDAB",
          "BDCABA"
        ],
        "expected": 4
      },
      {
        "input": [
          "ABCDEFG",
          "GFEDCBA"
        ],
        "expected": 4
      },
      {
        "input": [
          "ABC",
          "DEF"
        ],
        "expected": 0
      },
      {
        "input": [
          "",
          ""
        ],
        "expected": 0
      },
      {
        "input": [
          "A",
          "A"
        ],
        "expected": 1
      }
    ],
    "functionName": "findLongestCommonSubsequence",
    "hints": [
      "Hint 1: Use dynamic programming to solve this problem, as it has overlapping subproblems and optimal substructure.",
      "Hint 2: Create a 2D array to store the lengths of the longest common subsequences between substrings of the two input strings.",
      "Hint 3: Initialize the first row and column of the 2D array to 0, since the longest common subsequence between an empty string and a non-empty string is always 0."
    ]
  },
  {
    "id": 1074,
    "title": "Maximize Queue Efficiency",
    "difficulty": "advanced",
    "category": "Queue",
    "description": "Given a queue with a limited capacity and a list of tasks with their respective processing times, determine the maximum efficiency that can be achieved by processing the tasks in a specific order. Efficiency is calculated as the total processing time divided by the total time spent in the queue. The queue follows a First-In-First-Out (FIFO) order.",
    "examples": [
      {
        "input": "[[1, 2], [2, 3], [3, 1]]",
        "output": "1.5"
      },
      {
        "input": "[[1, 5], [2, 2], [3, 3]]",
        "output": "2.0"
      },
      {
        "input": "[[1, 1], [2, 1], [3, 1]]",
        "output": "1.0"
      }
    ],
    "starterCode": "function maximizeQueueEfficiency(tasks) {\n  // Your solution here\n  \n}",
    "testCases": [
      {
        "input": [
          [
            [
              1,
              2
            ],
            [
              2,
              3
            ],
            [
              3,
              1
            ]
          ]
        ],
        "expected": 1.5
      },
      {
        "input": [
          [
            [
              1,
              5
            ],
            [
              2,
              2
            ],
            [
              3,
              3
            ]
          ]
        ],
        "expected": 2
      },
      {
        "input": [
          [
            [
              1,
              1
            ],
            [
              2,
              1
            ],
            [
              3,
              1
            ]
          ]
        ],
        "expected": 1
      },
      {
        "input": [
          [
            [
              1,
              10
            ],
            [
              2,
              5
            ],
            [
              3,
              8
            ]
          ]
        ],
        "expected": 4.666666666666667
      },
      {
        "input": [
          [
            [
              1,
              1
            ],
            [
              2,
              1
            ],
            [
              3,
              1
            ],
            [
              4,
              1
            ]
          ]
        ],
        "expected": 1
      }
    ],
    "functionName": "maximizeQueueEfficiency",
    "hints": [
      "Hint 1: Sort the tasks based on their processing times to prioritize the tasks that take the longest to process.",
      "Hint 2: Use a priority queue to store the tasks and ensure that the task with the longest processing time is always processed first.",
      "Hint 3: Calculate the total processing time and the total time spent in the queue separately, and then divide the total processing time by the total time spent in the queue to get the maximum efficiency."
    ]
  },
  {
    "id": 1075,
    "title": "Detect Loop in Linked List",
    "difficulty": "beginner",
    "category": "Linked Lists",
    "description": "Given the head of a singly linked list, determine if the linked list has a cycle in it. A cycle is when a node's next pointer points back to a previous node.",
    "examples": [
      {
        "input": "[1, 2, 3, 4, 5]",
        "output": "false"
      },
      {
        "input": "[1, 2, 3, 4, 5, 2]",
        "output": "true"
      },
      {
        "input": "[1, 2]",
        "output": "false"
      }
    ],
    "starterCode": "function detectLoop(...args) {\n  // Your solution here\n  \n}",
    "testCases": [
      {
        "input": [
          [
            1,
            2,
            3,
            4,
            5
          ]
        ],
        "expected": false
      },
      {
        "input": [
          [
            1,
            2,
            3,
            4,
            5,
            2
          ]
        ],
        "expected": true
      },
      {
        "input": [
          [
            1,
            2
          ]
        ],
        "expected": false
      },
      {
        "input": [
          [
            1,
            2,
            3,
            4,
            5,
            4
          ]
        ],
        "expected": true
      },
      {
        "input": [
          [
            1
          ]
        ],
        "expected": false
      }
    ],
    "functionName": "detectLoop",
    "hints": [
      "Hint 1: Think about how you can traverse the linked list to detect a cycle. Consider using two pointers to traverse the list.",
      "Hint 2: Use a slow and fast pointer approach. The slow pointer moves one step at a time while the fast pointer moves two steps at a time. If there is a cycle, the fast and slow pointers will eventually meet.",
      "Hint 3: Make sure to handle edge cases such as an empty linked list or a linked list with only one node."
    ]
  },
  {
    "id": 1076,
    "title": "Fractional Number of Days Between Dates",
    "difficulty": "intermediate",
    "category": "Math",
    "description": "Write a function to calculate the fractional number of days between two dates. The function should take two dates as input in the format 'YYYY-MM-DD' and return the fractional number of days between them. Consider only the date part and ignore the time.",
    "examples": [
      {
        "input": "'2022-01-01', '2022-01-15'",
        "output": "14.0"
      },
      {
        "input": "'2020-12-31', '2021-01-01'",
        "output": "1.0"
      },
      {
        "input": "'2019-03-01', '2019-03-01'",
        "output": "0.0"
      }
    ],
    "starterCode": "function calculateFractionalDays(startDate, endDate) {\n  // Your solution here\n  \n}",
    "testCases": [
      {
        "input": [
          "2022-01-01",
          "2022-01-15"
        ],
        "expected": 14
      },
      {
        "input": [
          "2020-12-31",
          "2021-01-01"
        ],
        "expected": 1
      },
      {
        "input": [
          "2019-03-01",
          "2019-03-01"
        ],
        "expected": 0
      },
      {
        "input": [
          "2022-02-28",
          "2022-03-01"
        ],
        "expected": 1
      },
      {
        "input": [
          "2020-01-01",
          "2020-01-01"
        ],
        "expected": 0
      }
    ],
    "functionName": "calculateFractionalDays",
    "hints": [
      "Hint 1: Convert the input dates to a format that allows for easy date manipulation, such as the number of milliseconds since the Unix epoch.",
      "Hint 2: Use a library or built-in function to calculate the difference between the two dates in milliseconds, and then convert this difference to days.",
      "Hint 3: Consider the case where the input dates are in different months or years, and account for the varying number of days in each month."
    ]
  },
  {
    "id": 1077,
    "title": "Merge K Sorted Linked Lists With Limited Memory",
    "difficulty": "advanced",
    "category": "Linked Lists",
    "description": "Given K sorted linked lists and a limited amount of memory, merge them into one sorted linked list. Each node in the linked list has a value and a pointer to the next node. The limited memory constraint means that at any point in time, you can only store a constant amount of nodes in memory. The input linked lists are non-empty and the total number of nodes across all linked lists is N, where N is a positive integer.",
    "examples": [
      {
        "input": "[1 -> 4 -> 5, 1 -> 3 -> 4, 2 -> 6]",
        "output": "1 -> 1 -> 2 -> 3 -> 4 -> 4 -> 5 -> 6"
      },
      {
        "input": "[1 -> 2 -> 3, 4 -> 5 -> 6]",
        "output": "1 -> 2 -> 3 -> 4 -> 5 -> 6"
      },
      {
        "input": "[1, 2, 3]",
        "output": "1 -> 2 -> 3"
      }
    ],
    "starterCode": "function mergeKSortedLinkedLists(...args) {\n  // Your solution here\n  \n}",
    "testCases": [
      {
        "input": [
          [
            "1 -> 4 -> 5",
            "1 -> 3 -> 4",
            "2 -> 6"
          ]
        ],
        "expected": "1 -> 1 -> 2 -> 3 -> 4 -> 4 -> 5 -> 6"
      },
      {
        "input": [
          [
            "1 -> 2 -> 3",
            "4 -> 5 -> 6"
          ]
        ],
        "expected": "1 -> 2 -> 3 -> 4 -> 5 -> 6"
      },
      {
        "input": [
          [
            "1",
            "2",
            "3"
          ]
        ],
        "expected": "1 -> 2 -> 3"
      }
    ],
    "functionName": "mergeKSortedLinkedLists",
    "hints": [
      "Hint 1: Consider using a data structure that allows efficient extraction of the smallest element, such as a min-heap or a priority queue.",
      "Hint 2: Each node in the linked list can be represented as an object with a value and a pointer to the next node. You can store these objects in the min-heap or priority queue.",
      "Hint 3: To handle the limited memory constraint, consider processing the linked lists one node at a time, adding each node to the min-heap or priority queue and then removing the smallest node to add to the merged linked list."
    ]
  },
  {
    "id": 1080,
    "title": "Cryptic Cipher Decoding",
    "difficulty": "advanced",
    "category": "Backtracking",
    "description": "You are given a set of cryptic rules to decode a cipher. The cipher consists of a string of characters where each character can be either a letter or a digit. The rules are as follows: (1) any letter can be replaced by any other letter, (2) any digit can be replaced by any other digit, and (3) the resulting decoded string must be a valid English word. Given a cipher string and a dictionary of valid English words, decode the cipher to find all possible valid English words that can be formed.",
    "examples": [
      {
        "input": "1a2b",
        "output": "[\"lab\", \"lac\", \"lad\", \"lag\"]"
      },
      {
        "input": "abc",
        "output": "[\"abc\", \"abd\", \"abe\", \"abf\"]"
      },
      {
        "input": "123",
        "output": "[\"101\", \"102\", \"103\"]"
      }
    ],
    "starterCode": "function decodeCipher(...args) {\n  // Your solution here\n  \n}",
    "testCases": [
      {
        "input": [
          "1a2b",
          [
            "lab",
            "lac",
            "lad",
            "lag"
          ]
        ],
        "expected": [
          "lab",
          "lac",
          "lad",
          "lag"
        ]
      },
      {
        "input": [
          "abc",
          [
            "abc",
            "abd",
            "abe",
            "abf"
          ]
        ],
        "expected": [
          "abc",
          "abd",
          "abe",
          "abf"
        ]
      },
      {
        "input": [
          "123",
          [
            "101",
            "102",
            "103"
          ]
        ],
        "expected": [
          "101",
          "102",
          "103"
        ]
      },
      {
        "input": [
          "",
          [
            ""
          ]
        ],
        "expected": [
          ""
        ]
      },
      {
        "input": [
          "a",
          [
            "a",
            "b",
            "c"
          ]
        ],
        "expected": [
          "a"
        ]
      }
    ],
    "functionName": "decodeCipher",
    "hints": [
      "Hint 1: Use a backtracking approach to generate all possible combinations of the cipher string.",
      "Hint 2: Create a trie data structure to efficiently store and look up the dictionary of valid English words.",
      "Hint 3: Implement a recursive function to explore all possible decodings of the cipher string, and use the trie to validate each decoding."
    ]
  },
  {
    "id": 1081,
    "title": "Find Consecutive Sum",
    "difficulty": "beginner",
    "category": "Arrays",
    "description": "Given an array of integers and a target sum, find the first pair of consecutive elements that add up to the target sum. If no such pair exists, return an empty array.",
    "examples": [
      {
        "input": "[1, 2, 3, 4, 5], 7",
        "output": "[2, 5]"
      },
      {
        "input": "[10, 20, 30, 40, 50], 60",
        "output": "[10, 50]"
      },
      {
        "input": "[5, 5, 5, 5, 5], 10",
        "output": "[5, 5]"
      }
    ],
    "starterCode": "function findConsecutiveSum(arr, target) {\n  // Your solution here\n  \n}",
    "testCases": [
      {
        "input": [
          [
            1,
            2,
            3,
            4,
            5
          ],
          7
        ],
        "expected": [
          2,
          5
        ]
      },
      {
        "input": [
          [
            10,
            20,
            30,
            40,
            50
          ],
          60
        ],
        "expected": [
          10,
          50
        ]
      },
      {
        "input": [
          [
            5,
            5,
            5,
            5,
            5
          ],
          10
        ],
        "expected": [
          5,
          5
        ]
      },
      {
        "input": [
          [
            1,
            2,
            3,
            4,
            5
          ],
          100
        ],
        "expected": []
      }
    ],
    "functionName": "findConsecutiveSum",
    "hints": [
      "Hint 1: Iterate through the array and consider each element as a potential starting point for the pair.",
      "Hint 2: Use a simple addition operation to check if the sum of the current element and the next element equals the target sum.",
      "Hint 3: Consider edge cases, such as an empty array or an array with only one element, and handle them accordingly to avoid errors."
    ]
  },
  {
    "id": 1082,
    "title": "Valid Parentheses Substrings",
    "difficulty": "intermediate",
    "category": "Stack",
    "description": "Given a string of parentheses, find the length of the longest valid substring. A valid substring is one that has a matching pair of parentheses for every opening parenthesis. The input string will only contain parentheses.",
    "examples": [
      {
        "input": "(()",
        "output": "2"
      },
      {
        "input": ")()())",
        "output": "4"
      },
      {
        "input": "",
        "output": "0"
      }
    ],
    "starterCode": "function longestValidSubstring(s) {\n  // Your solution here\n  \n}",
    "testCases": [
      {
        "input": [
          "()"
        ],
        "expected": 2
      },
      {
        "input": [
          "(()()"
        ],
        "expected": 4
      },
      {
        "input": [
          ")()())"
        ],
        "expected": 4
      },
      {
        "input": [
          ""
        ],
        "expected": 0
      }
    ],
    "functionName": "longestValidSubstring",
    "hints": [
      "Hint 1: To find the longest valid substring, consider using a data structure that allows you to efficiently keep track of the opening and closing parentheses.",
      "Hint 2: A stack data structure can be particularly useful for this problem, as it allows you to match opening and closing parentheses and keep track of their indices.",
      "Hint 3: When using a stack, consider how you can use the indices of the opening parentheses to determine the length of the valid substrings and keep track of the maximum length found so far."
    ]
  },
  {
    "id": 1083,
    "title": "minimumWindowSubstringWithKRepeatingCharacters",
    "difficulty": "advanced",
    "category": "Strings",
    "description": "Given a string and an integer k, find the minimum window substring that contains exactly k repeating characters. A repeating character is a character that appears more than once in the substring.",
    "examples": [
      {
        "input": "[\"abcab\", 2]",
        "output": "\"cab\""
      },
      {
        "input": "[\"abccba\", 2]",
        "output": "\"bccb\""
      },
      {
        "input": "[\"aaaa\", 2]",
        "output": "\"aa\""
      }
    ],
    "starterCode": "function minimumWindowSubstringWithKRepeatingCharacters(s, k) {\n  // Your solution here\n}",
    "testCases": [
      {
        "input": [
          "abcab",
          2
        ],
        "expected": "cab"
      },
      {
        "input": [
          "abccba",
          2
        ],
        "expected": "bccb"
      },
      {
        "input": [
          "aaaa",
          2
        ],
        "expected": "aa"
      },
      {
        "input": [
          "abcdef",
          2
        ],
        "expected": ""
      },
      {
        "input": [
          "aabbcc",
          3
        ],
        "expected": "aabbcc"
      }
    ],
    "functionName": "minimumWindowSubstringWithKRepeatingCharacters",
    "hints": [
      "Hint 1: Use the sliding window technique to find the minimum window substring. This involves maintaining a window of characters and expanding or shrinking it as needed to meet the condition.",
      "Hint 2: Use a frequency map to keep track of the characters in the current window and their frequencies. This will help you determine when the window contains exactly k repeating characters.",
      "Hint 3: When shrinking the window, make sure to update the frequency map and check if the character being removed is a repeating character. If it is, decrement its frequency and update the window boundaries accordingly."
    ]
  },
  {
    "id": 1084,
    "title": "Valid Parentheses Stack",
    "difficulty": "beginner",
    "category": "Stack",
    "description": "Given a string of parentheses, determine if they are balanced and valid. A string of parentheses is valid if every open parenthesis can be matched with a corresponding close parenthesis.",
    "examples": [
      {
        "input": "((()))",
        "output": "true"
      },
      {
        "input": "(()",
        "output": "false"
      },
      {
        "input": "()",
        "output": "true"
      }
    ],
    "starterCode": "function validParentheses(str) {\n  // Your solution here\n  \n}",
    "testCases": [
      {
        "input": [
          "((()))"
        ],
        "expected": true
      },
      {
        "input": [
          "(()"
        ],
        "expected": false
      },
      {
        "input": [
          "()"
        ],
        "expected": true
      },
      {
        "input": [
          ""
        ],
        "expected": true
      },
      {
        "input": [
          "("
        ],
        "expected": false
      }
    ],
    "functionName": "validParentheses",
    "hints": [
      "Hint 1: Use a stack data structure to keep track of the opening parentheses.",
      "Hint 2: When encountering a closing parenthesis, check if the stack is empty or the top of the stack does not match the current closing parenthesis.",
      "Hint 3: After processing the entire string, check if the stack is empty to determine if all parentheses were matched correctly."
    ]
  },
  {
    "id": 1085,
    "title": "Subarray Product Query",
    "difficulty": "intermediate",
    "category": "Arrays",
    "description": "Given an array of integers and a target product, find all subarrays where the product of the elements equals the target product. The function should return the number of such subarrays.",
    "examples": [
      {
        "input": "[1, 2, 3, 4], 6",
        "output": "2"
      },
      {
        "input": "[5, 10, 20], 100",
        "output": "1"
      },
      {
        "input": "[1, 1, 1], 1",
        "output": "6"
      }
    ],
    "starterCode": "function subarrayProductQuery(arr, targetProduct) {\n  // Your solution here\n  \n}",
    "testCases": [
      {
        "input": [
          [
            1,
            2,
            3,
            4
          ],
          6
        ],
        "expected": 2
      },
      {
        "input": [
          [
            5,
            10,
            20
          ],
          100
        ],
        "expected": 1
      },
      {
        "input": [
          [
            1,
            1,
            1
          ],
          1
        ],
        "expected": 6
      },
      {
        "input": [
          [
            10,
            20,
            30
          ],
          900
        ],
        "expected": 0
      },
      {
        "input": [
          [
            1,
            2,
            3
          ],
          0
        ],
        "expected": 0
      }
    ],
    "functionName": "subarrayProductQuery",
    "hints": [
      "Hint 1: Use a brute force approach to generate all possible subarrays and check their product. Although not efficient, it will give you a starting point to optimize later.",
      "Hint 2: Consider using a prefix product array to efficiently calculate the product of any subarray in constant time. This can significantly reduce the time complexity of your solution.",
      "Hint 3: Take advantage of the fact that if the product of a subarray is equal to the target product, and the subarray has more than one element, then the product of any proper subset of this subarray must be less than the target product. Use this insight to optimize your solution and avoid unnecessary computations."
    ]
  },
  {
    "id": 1086,
    "title": "Mountain Peak Finder",
    "difficulty": "advanced",
    "category": "Binary Search",
    "description": "Given an array of integers representing the elevation of a mountain at different points, find the index of the peak of the mountain, which is the point where the elevation starts to decrease. The mountain array is guaranteed to have a peak, and the elevation at the peak is greater than the elevations at adjacent points. If there are multiple peaks, return the index of the first one.",
    "examples": [
      {
        "input": "[0, 1, 2, 3, 4, 5, 4, 3, 2, 1, 0]",
        "output": "5"
      },
      {
        "input": "[0, 1, 2, 1, 0]",
        "output": "2"
      },
      {
        "input": "[1, 2, 3, 2, 1]",
        "output": "2"
      }
    ],
    "starterCode": "function findMountainPeak(...args) {\n  // Your solution here\n  \n}",
    "testCases": [
      {
        "input": [
          [
            0,
            1,
            2,
            3,
            4,
            5,
            4,
            3,
            2,
            1,
            0
          ]
        ],
        "expected": 5
      },
      {
        "input": [
          [
            0,
            1,
            2,
            1,
            0
          ]
        ],
        "expected": 2
      },
      {
        "input": [
          [
            1,
            2,
            3,
            2,
            1
          ]
        ],
        "expected": 2
      },
      {
        "input": [
          [
            1,
            3,
            20,
            4,
            1,
            0
          ]
        ],
        "expected": 2
      }
    ],
    "functionName": "findMountainPeak",
    "hints": [
      "Hint 1: Use a binary search approach to find the peak, but be careful because the mountain array is not necessarily sorted.",
      "Hint 2: Consider the middle element of the current search range. If the middle element is greater than its adjacent elements, it could be the peak. Otherwise, the peak must be in the half of the range where the elevation is increasing.",
      "Hint 3: To handle edge cases, make sure to check the boundaries of the search range and consider the case where the peak is at the start or end of the array."
    ]
  },
  {
    "id": 1087,
    "title": "Bitwise Pairwise And",
    "difficulty": "beginner",
    "category": "Bit Manipulation",
    "description": "Given an array of integers, write a function that calculates the bitwise AND of all pairs of numbers in the array and returns the maximum result.",
    "examples": [
      {
        "input": "[1, 2, 3]",
        "output": "1"
      },
      {
        "input": "[5, 7, 9]",
        "output": "1"
      },
      {
        "input": "[10, 12, 14]",
        "output": "10"
      }
    ],
    "starterCode": "function bitwisePairwiseAnd(...args) {\n  // Your solution here\n  \n}",
    "testCases": [
      {
        "input": [
          [
            1,
            2,
            3
          ]
        ],
        "expected": 1
      },
      {
        "input": [
          [
            5,
            7,
            9
          ]
        ],
        "expected": 1
      },
      {
        "input": [
          [
            10,
            12,
            14
          ]
        ],
        "expected": 10
      },
      {
        "input": [
          [
            1,
            1,
            1
          ]
        ],
        "expected": 1
      },
      {
        "input": [
          [
            0,
            0,
            0
          ]
        ],
        "expected": 0
      }
    ],
    "functionName": "bitwisePairwiseAnd",
    "hints": [
      "Hint 1: Start by understanding the properties of bitwise AND operation and how it can be applied to pairs of numbers.",
      "Hint 2: Consider using a nested loop to generate all possible pairs of numbers from the input array and calculate the bitwise AND for each pair.",
      "Hint 3: To find the maximum result, use the Math.max function in conjunction with the bitwise AND operation to keep track of the maximum result encountered so far."
    ]
  },
  {
    "id": 1088,
    "title": "Merge Sorted Linked Lists With Duplicate Removal",
    "difficulty": "intermediate",
    "category": "Linked Lists",
    "description": "Given two sorted linked lists, merge them into a single sorted linked list and remove any duplicate values. The linked lists are defined by a series of nodes, each with a value and a pointer to the next node.",
    "examples": [
      {
        "input": "[1, 3, 5] and [2, 3, 7]",
        "output": "[1, 2, 3, 5, 7]"
      },
      {
        "input": "[1, 2, 3] and [4, 5, 6]",
        "output": "[1, 2, 3, 4, 5, 6]"
      },
      {
        "input": "[1, 1, 1] and [1, 1, 1]",
        "output": "[1]"
      }
    ],
    "starterCode": "function mergeSortedLists(...args) {\n  // Your solution here\n  \n}",
    "testCases": [
      {
        "input": [
          [
            1,
            3,
            5
          ],
          [
            2,
            3,
            7
          ]
        ],
        "expected": [
          1,
          2,
          3,
          5,
          7
        ]
      },
      {
        "input": [
          [
            1,
            2,
            3
          ],
          [
            4,
            5,
            6
          ]
        ],
        "expected": [
          1,
          2,
          3,
          4,
          5,
          6
        ]
      },
      {
        "input": [
          [
            1,
            1,
            1
          ],
          [
            1,
            1,
            1
          ]
        ],
        "expected": [
          1
        ]
      },
      {
        "input": [
          [],
          [
            1,
            2,
            3
          ]
        ],
        "expected": [
          1,
          2,
          3
        ]
      },
      {
        "input": [
          [
            1,
            2,
            3
          ],
          []
        ],
        "expected": [
          1,
          2,
          3
        ]
      }
    ],
    "functionName": "mergeSortedLists",
    "hints": [
      "Hint 1: Use a standard merge approach for sorted lists, considering the smaller value at each step to build the new list.",
      "Hint 2: Keep track of the last added value to avoid duplicates, potentially using a Set for efficient lookup.",
      "Hint 3: Handle edge cases where one or both input lists are empty, ensuring your function remains robust and efficient."
    ]
  },
  {
    "id": 1089,
    "title": "Implementing a Stack with a Dynamic Min Stack",
    "difficulty": "advanced",
    "category": "Stack",
    "description": "Design a stack that supports the standard push and pop operations, as well as an additional operation called getMin, which returns the minimum element in the stack. The getMin operation should be efficient and not require scanning the entire stack. Implement this stack using an array and handle cases where the stack is empty or full.",
    "examples": [
      {
        "input": "push(5), push(10), getMin(), pop(), getMin()",
        "output": "5, 5"
      },
      {
        "input": "push(10), push(5), getMin(), pop(), getMin()",
        "output": "5, 10"
      },
      {
        "input": "push(5), push(5), getMin(), pop(), getMin()",
        "output": "5, 5"
      }
    ],
    "starterCode": "function minStack(...args) {\n  // Your solution here\n  \n}",
    "testCases": [
      {
        "input": [
          5,
          10,
          "getMin",
          "pop",
          "getMin"
        ],
        "expected": [
          5,
          5
        ]
      },
      {
        "input": [
          10,
          5,
          "getMin",
          "pop",
          "getMin"
        ],
        "expected": [
          5,
          10
        ]
      },
      {
        "input": [
          5,
          5,
          "getMin",
          "pop",
          "getMin"
        ],
        "expected": [
          5,
          5
        ]
      },
      {
        "input": [
          "pop"
        ],
        "expected": "Stack is empty"
      },
      {
        "input": [
          10,
          5,
          "getMin"
        ],
        "expected": 5
      }
    ],
    "functionName": "minStack",
    "hints": [
      "Consider using an auxiliary stack to keep track of the minimum elements seen so far, this will help you to efficiently get the minimum element in O(1) time.",
      "The auxiliary stack should be updated whenever a new element is pushed onto the main stack, but the update rule should be based on the comparison between the new element and the current minimum element in the auxiliary stack.",
      "When an element is popped from the main stack, you should also consider popping the corresponding element from the auxiliary stack if it matches the popped element, this will ensure the auxiliary stack remains consistent with the main stack."
    ]
  },
  {
    "id": 1091,
    "title": "Subarray Product Threshold",
    "difficulty": "intermediate",
    "category": "Arrays",
    "description": "Given an array of integers and an integer threshold, find the number of subarrays where the product of all elements in the subarray is less than or equal to the threshold. The subarray must have at least one element.",
    "examples": [
      {
        "input": "[1, 2, 3], 6",
        "output": "6"
      },
      {
        "input": "[1, 2, 3, 4], 24",
        "output": "10"
      },
      {
        "input": "[5], 5",
        "output": "1"
      }
    ],
    "starterCode": "function subarrayProductThreshold(arr, threshold) {\n  // Your solution here\n  \n}",
    "testCases": [
      {
        "input": [
          [
            1,
            2,
            3
          ],
          6
        ],
        "expected": 6
      },
      {
        "input": [
          [
            1,
            2,
            3,
            4
          ],
          24
        ],
        "expected": 10
      },
      {
        "input": [
          [
            5
          ],
          5
        ],
        "expected": 1
      },
      {
        "input": [
          [
            10,
            20,
            30
          ],
          100
        ],
        "expected": 2
      },
      {
        "input": [
          [
            1,
            1,
            1
          ],
          1
        ],
        "expected": 3
      }
    ],
    "functionName": "subarrayProductThreshold",
    "hints": [
      "Hint 1: Use a sliding window approach to efficiently generate all possible subarrays from the given array.",
      "Hint 2: Keep track of the product of elements in the current window and adjust the window boundaries based on whether the product exceeds the threshold.",
      "Hint 3: Be mindful of the case where the array contains zeros, as they can greatly affect the product of elements in a subarray."
    ]
  },
  {
    "id": 1094,
    "title": "Knight's Tour Problem",
    "difficulty": "intermediate",
    "category": "Backtracking",
    "description": "The Knight's Tour is a classic problem where a knight on a chessboard must visit each square exactly once. Given an n x n chessboard, find all possible tours that the knight can take.",
    "examples": [
      {
        "input": "n = 4",
        "output": "All possible tours on a 4x4 chessboard"
      },
      {
        "input": "n = 5",
        "output": "All possible tours on a 5x5 chessboard"
      },
      {
        "input": "n = 6",
        "output": "All possible tours on a 6x6 chessboard"
      }
    ],
    "starterCode": "function knightsTour(n) {\n  // Your solution here\n  \n}",
    "testCases": [
      {
        "input": [
          4
        ],
        "expected": [
          [
            "(0,0)",
            "(2,1)",
            "(4,2)",
            "(6,3)",
            "(5,1)",
            "(7,0)",
            "(6,2)",
            "(4,0)",
            "(5,3)",
            "(7,1)",
            "(6,3)",
            "(4,1)",
            "(2,0)",
            "(0,2)",
            "(1,0)",
            "(3,2)"
          ]
        ]
      },
      {
        "input": [
          5
        ],
        "expected": [
          [
            "(0,0)",
            "(2,1)",
            "(4,2)",
            "(6,3)",
            "(7,1)",
            "(5,3)",
            "(7,0)",
            "(6,2)",
            "(4,0)",
            "(5,2)",
            "(3,0)",
            "(1,2)",
            "(0,4)",
            "(2,3)",
            "(4,1)",
            "(6,0)",
            "(5,4)",
            "(7,2)",
            "(6,4)",
            "(5,1)",
            "(3,3)",
            "(1,1)",
            "(0,3)"
          ]
        ]
      },
      {
        "input": [
          6
        ],
        "expected": [
          [
            "(0,0)",
            "(2,1)",
            "(4,2)",
            "(6,3)",
            "(7,1)",
            "(5,3)",
            "(7,0)",
            "(6,2)",
            "(4,0)",
            "(5,2)",
            "(3,0)",
            "(1,2)",
            "(0,4)",
            "(2,3)",
            "(4,1)",
            "(6,0)",
            "(5,4)",
            "(7,2)",
            "(6,4)",
            "(5,1)",
            "(3,3)",
            "(1,1)",
            "(0,3)",
            "(2,5)",
            "(4,4)",
            "(6,1)"
          ]
        ]
      }
    ],
    "functionName": "knightsTour",
    "hints": [
      "Hint 1: Use a recursive backtracking approach to explore all possible moves from each square",
      "Hint 2: Utilize a 2D array or matrix to represent the chessboard and keep track of visited squares",
      "Hint 3: Implement the knight's move rules and handle edge cases, such as when the knight is at the boundary of the chessboard"
    ]
  },
  {
    "id": 1095,
    "title": "Peak Index in Mountain Array",
    "difficulty": "advanced",
    "category": "Binary Search",
    "description": "An array of integers is called a mountain array if it meets the following conditions: it is strictly increasing until it reaches its peak, and then it is strictly decreasing. Given a mountain array, find the index of the peak element. The mountain array is guaranteed to have a peak element.",
    "examples": [
      {
        "input": "[0, 1, 2, 3, 2, 1, 0]",
        "output": "3"
      },
      {
        "input": "[1, 2, 3, 4, 5, 4, 3, 2, 1]",
        "output": "4"
      },
      {
        "input": "[2, 3, 4, 5, 1]",
        "output": "3"
      }
    ],
    "starterCode": "function findPeakIndex(...args) {\n  // Your solution here\n  \n}",
    "testCases": [
      {
        "input": [
          [
            0,
            1,
            2,
            3,
            2,
            1,
            0
          ]
        ],
        "expected": 3
      },
      {
        "input": [
          [
            1,
            2,
            3,
            4,
            5,
            4,
            3,
            2,
            1
          ]
        ],
        "expected": 4
      },
      {
        "input": [
          [
            2,
            3,
            4,
            5,
            1
          ]
        ],
        "expected": 3
      }
    ],
    "functionName": "findPeakIndex",
    "hints": [
      "Hint 1: We can use a modified binary search algorithm to find the peak element, as the array is sorted in a specific way until the peak and then sorted in reverse after the peak.",
      "Hint 2: When choosing the middle element in the binary search, compare the middle element with the next element to determine whether we should continue searching in the left or right half of the array.",
      "Hint 3: Be careful when handling edge cases such as arrays with only two elements or arrays where the peak is at the start or end of the array."
    ]
  },
  {
    "id": 1096,
    "title": "Find the First Occurrence of a Target in a Sorted Array",
    "difficulty": "beginner",
    "category": "Binary Search",
    "description": "Given a sorted array of integers and a target value, find the index of the first occurrence of the target value in the array. If the target value is not found, return -1.",
    "examples": [
      {
        "input": "[1, 2, 2, 3, 4, 5], 2",
        "output": "1"
      },
      {
        "input": "[1, 1, 2, 2, 3, 3], 3",
        "output": "4"
      },
      {
        "input": "[1, 2, 3, 4, 5], 6",
        "output": "-1"
      }
    ],
    "starterCode": "function findFirstOccurrence(arr, target) {\n  // Your solution here\n  \n}",
    "testCases": [
      {
        "input": [
          [
            1,
            2,
            2,
            3,
            4,
            5
          ],
          2
        ],
        "expected": 1
      },
      {
        "input": [
          [
            1,
            1,
            2,
            2,
            3,
            3
          ],
          3
        ],
        "expected": 4
      },
      {
        "input": [
          [
            1,
            2,
            3,
            4,
            5
          ],
          6
        ],
        "expected": -1
      },
      {
        "input": [
          [
            1
          ],
          1
        ],
        "expected": 0
      },
      {
        "input": [
          [],
          1
        ],
        "expected": -1
      }
    ],
    "functionName": "findFirstOccurrence",
    "hints": [
      "Hint 1: Use a binary search approach to find the target value in the sorted array, but consider how you will handle duplicate values.",
      "Hint 2: When the target value is found, instead of immediately returning the index, consider how you can adjust the search range to find the first occurrence of the target value.",
      "Hint 3: Think about the edge cases where the target value is not found in the array, or where the array is empty, and how you can handle these cases in your solution."
    ]
  },
  {
    "id": 1097,
    "title": "Lowest Common Ancestor in a Binary Tree with Duplicate Values",
    "difficulty": "intermediate",
    "category": "Trees",
    "description": "Given a binary tree where each node has a unique id and a value that may be duplicated, find the lowest common ancestor of two nodes with given ids. The tree is not guaranteed to be balanced, and the nodes are not guaranteed to be in any specific order.",
    "examples": [
      {
        "input": "[{id: 1, value: 1, left: {id: 2, value: 2}, right: {id: 3, value: 1}}, 2, 3]",
        "output": "{id: 1, value: 1}"
      },
      {
        "input": "[{id: 1, value: 1, left: {id: 2, value: 2}, right: {id: 3, value: 3}}, 2, 3]",
        "output": "{id: 1, value: 1}"
      },
      {
        "input": "[{id: 1, value: 1, left: {id: 2, value: 1}, right: {id: 3, value: 1}}, 2, 3]",
        "output": "{id: 1, value: 1}"
      }
    ],
    "starterCode": "function findLowestCommonAncestor(root, id1, id2) {\n  // Your solution here\n  \n}",
    "testCases": [
      {
        "input": [
          {
            "id": 1,
            "value": 1,
            "left": {
              "id": 2,
              "value": 2
            },
            "right": {
              "id": 3,
              "value": 1
            }
          },
          2,
          3
        ],
        "expected": {
          "id": 1,
          "value": 1
        }
      },
      {
        "input": [
          {
            "id": 1,
            "value": 1,
            "left": {
              "id": 2,
              "value": 2
            },
            "right": {
              "id": 3,
              "value": 3
            }
          },
          2,
          3
        ],
        "expected": {
          "id": 1,
          "value": 1
        }
      },
      {
        "input": [
          {
            "id": 1,
            "value": 1,
            "left": {
              "id": 2,
              "value": 1
            },
            "right": {
              "id": 3,
              "value": 1
            }
          },
          2,
          3
        ],
        "expected": {
          "id": 1,
          "value": 1
        }
      },
      {
        "input": [
          {
            "id": 1,
            "value": 1,
            "left": {
              "id": 2,
              "value": 2
            },
            "right": null
          },
          1,
          2
        ],
        "expected": {
          "id": 1,
          "value": 1
        }
      },
      {
        "input": [
          {
            "id": 1,
            "value": 1,
            "left": null,
            "right": {
              "id": 2,
              "value": 2
            }
          },
          1,
          2
        ],
        "expected": {
          "id": 1,
          "value": 1
        }
      }
    ],
    "functionName": "findLowestCommonAncestor",
    "hints": [
      "Hint 1: Start by finding the paths from the root to each of the given nodes. This can be done using a recursive or iterative approach.",
      "Hint 2: Once the paths are found, compare them to find the last common node. This can be done by iterating through the paths in reverse order and checking for equality.",
      "Hint 3: Be careful when handling edge cases, such as when one of the given nodes is the root or when the tree is not balanced. Make sure to consider these cases when implementing the solution."
    ]
  },
  {
    "id": 1098,
    "title": "Minimum Edge Removal to Make Graph Acyclic",
    "difficulty": "advanced",
    "category": "Graphs",
    "description": "Given a directed graph, find the minimum number of edges to remove to make the graph acyclic. The graph is represented as an adjacency list, where each index represents a node and the value at that index is a list of its neighbors.",
    "examples": [
      {
        "input": "[[1], [2], [3], []]",
        "output": "1"
      },
      {
        "input": "[[1, 2], [2], [3], []]",
        "output": "1"
      },
      {
        "input": "[[1], [2], [0], []]",
        "output": "2"
      }
    ],
    "starterCode": "function minEdgeRemoval(graph) {\n  // Your solution here\n  \n}",
    "testCases": [
      {
        "input": [
          [
            [
              1
            ],
            [
              2
            ],
            [
              3
            ],
            []
          ]
        ],
        "expected": 1
      },
      {
        "input": [
          [
            [
              1,
              2
            ],
            [
              2
            ],
            [
              3
            ],
            []
          ]
        ],
        "expected": 1
      },
      {
        "input": [
          [
            [
              1
            ],
            [
              2
            ],
            [
              0
            ],
            []
          ]
        ],
        "expected": 2
      },
      {
        "input": [
          [
            [],
            [],
            [],
            []
          ]
        ],
        "expected": 0
      },
      {
        "input": [
          [
            [
              1,
              2,
              3
            ],
            [
              2,
              3
            ],
            [
              3
            ],
            []
          ]
        ],
        "expected": 3
      }
    ],
    "functionName": "minEdgeRemoval",
    "hints": [
      "Hint 1: To solve this problem, we need to find the minimum number of edges to remove to make the graph acyclic. This can be achieved by finding all simple cycles in the graph and removing the minimum number of edges that break all cycles.",
      "Hint 2: We can use depth-first search (DFS) to detect cycles in the graph and find all simple cycles. We also need to keep track of the edges that are part of a cycle.",
      "Hint 3: To find the minimum number of edges to remove, we can use the concept of 'edge contraction'. We can contract edges that are part of a cycle, and then remove the contracted edges to break all cycles."
    ]
  },
  {
    "id": 1099,
    "title": "Kth Largest Number in a Stream",
    "difficulty": "beginner",
    "category": "Heap",
    "description": "Design a class that continuously receives a stream of integers and returns the kth largest number at any given time. The class should have a method to add a new number to the stream and a method to get the kth largest number. The class should use a min-heap data structure to efficiently store and retrieve the kth largest number.",
    "examples": [
      {
        "input": "add(5), add(3), add(7), getKthLargest(2)",
        "output": "5"
      },
      {
        "input": "add(10), add(20), add(30), getKthLargest(1)",
        "output": "30"
      },
      {
        "input": "add(1), add(2), add(3), getKthLargest(3)",
        "output": "1"
      }
    ],
    "starterCode": "function kthLargestNumber(...args) {\n  // Your solution here\n  \n}",
    "testCases": [
      {
        "input": [
          [
            5,
            3,
            7
          ],
          2
        ],
        "expected": 5
      },
      {
        "input": [
          [
            10,
            20,
            30
          ],
          1
        ],
        "expected": 30
      },
      {
        "input": [
          [
            1,
            2,
            3
          ],
          3
        ],
        "expected": 1
      },
      {
        "input": [
          [
            1
          ],
          1
        ],
        "expected": 1
      },
      {
        "input": [
          [],
          1
        ],
        "expected": null
      }
    ],
    "functionName": "kthLargestNumber",
    "hints": [
      "Hint 1: Design a class with two methods, one to add a new number to the stream and another to get the kth largest number.",
      "Hint 2: Use a min-heap data structure to store the k largest numbers. When the heap size exceeds k, remove the smallest number.",
      "Hint 3: Consider edge cases such as an empty stream, k larger than the stream size, or duplicate numbers in the stream."
    ]
  },
  {
    "id": 1100,
    "title": "Coin Changing Problem with Limited Coins",
    "difficulty": "intermediate",
    "category": "Greedy",
    "description": "Given a set of coins with limited quantities and a target amount, find the minimum number of coins required to reach the target amount. Each coin can be used multiple times but only up to its limited quantity.",
    "examples": [
      {
        "input": "[1, 2, 5], [10, 10, 10], 17",
        "output": "5"
      },
      {
        "input": "[1, 5, 10], [5, 2, 1], 15",
        "output": "3"
      },
      {
        "input": "[2, 5], [5, 5], 7",
        "output": "4"
      }
    ],
    "starterCode": "function minCoins(coins, quantities, target) {\n  // Your solution here\n  \n}",
    "testCases": [
      {
        "input": [
          [
            1,
            2,
            5
          ],
          [
            10,
            10,
            10
          ],
          17
        ],
        "expected": 5
      },
      {
        "input": [
          [
            1,
            5,
            10
          ],
          [
            5,
            2,
            1
          ],
          15
        ],
        "expected": 3
      },
      {
        "input": [
          [
            2,
            5
          ],
          [
            5,
            5
          ],
          7
        ],
        "expected": 4
      },
      {
        "input": [
          [
            1
          ],
          [
            10
          ],
          10
        ],
        "expected": 10
      },
      {
        "input": [
          [
            1,
            2
          ],
          [
            5,
            5
          ],
          7
        ],
        "expected": 4
      }
    ],
    "functionName": "minCoins",
    "hints": [
      "Consider using a greedy approach by always choosing the largest coin that doesn't exceed the remaining target amount, while also keeping track of the available quantities of each coin.",
      "To optimize the solution, sort the coins in descending order and iterate over them to construct the optimal combination, while updating the remaining target amount and available quantities.",
      "When a coin is used, reduce its available quantity and update the remaining target amount; if a coin's quantity reaches zero, remove it from consideration for future iterations."
    ]
  },
  {
    "id": 1102,
    "title": "Kth Largest Element In Heap",
    "difficulty": "beginner",
    "category": "Heap",
    "description": "Given a max heap and an integer k, find the kth largest element in the heap. The max heap is represented as an array where the parent node is always greater than or equal to its child nodes. The kth largest element is the kth largest number in the sorted array.",
    "examples": [
      {
        "input": "[4, 2, 9, 1, 5, 3] k = 2",
        "output": "5"
      },
      {
        "input": "[10, 5, 3, 2, 8] k = 1",
        "output": "10"
      },
      {
        "input": "[7, 3, 2, 1, 4] k = 3",
        "output": "3"
      }
    ],
    "starterCode": "function findKthLargest(...args) {\n  // Your solution here\n  \n}",
    "testCases": [
      {
        "input": [
          [
            4,
            2,
            9,
            1,
            5,
            3
          ],
          2
        ],
        "expected": 5
      },
      {
        "input": [
          [
            10,
            5,
            3,
            2,
            8
          ],
          1
        ],
        "expected": 10
      },
      {
        "input": [
          [
            7,
            3,
            2,
            1,
            4
          ],
          3
        ],
        "expected": 3
      },
      {
        "input": [
          [
            1
          ],
          1
        ],
        "expected": 1
      },
      {
        "input": [
          [],
          1
        ],
        "expected": null
      }
    ],
    "functionName": "findKthLargest",
    "hints": [
      "Hint 1: First, understand the properties of a max heap and how it is represented as an array. Think about how you can leverage these properties to find the kth largest element.",
      "Hint 2: Consider using a data structure that allows for efficient extraction of the maximum element, such as a priority queue or a heap data structure itself.",
      "Hint 3: Be mindful of edge cases, such as when k is larger than the number of elements in the heap, or when the heap is empty. Think about how you can handle these cases in your solution."
    ]
  },
  {
    "id": 1104,
    "title": "Greatest Common Divisor of Polynomial Coefficients",
    "difficulty": "advanced",
    "category": "Math",
    "description": "Given two polynomials, find the greatest common divisor (GCD) of their coefficients. The coefficients are represented as arrays of integers, where the index represents the power of the variable. For example, the polynomial 3x^2 + 2x - 4 is represented as [-4, 2, 3].",
    "examples": [
      {
        "input": "[-4, 2, 3], [1, -2, 1]",
        "output": "1"
      },
      {
        "input": "[1, 2, 3], [3, 2, 1]",
        "output": "1"
      },
      {
        "input": "[2, 4, 6], [4, 8, 12]",
        "output": "2"
      }
    ],
    "starterCode": "function findGcdOfCoefficients(poly1, poly2) {\n  // Your solution here\n  \n}",
    "testCases": [
      {
        "input": [
          [
            -4,
            2,
            3
          ],
          [
            1,
            -2,
            1
          ]
        ],
        "expected": 1
      },
      {
        "input": [
          [
            1,
            2,
            3
          ],
          [
            3,
            2,
            1
          ]
        ],
        "expected": 1
      },
      {
        "input": [
          [
            2,
            4,
            6
          ],
          [
            4,
            8,
            12
          ]
        ],
        "expected": 2
      },
      {
        "input": [
          [
            1
          ],
          [
            1
          ]
        ],
        "expected": 1
      },
      {
        "input": [
          [
            0
          ],
          [
            5
          ]
        ],
        "expected": 1
      }
    ],
    "functionName": "findGcdOfCoefficients",
    "hints": [
      "Hint 1: The problem can be solved by finding the GCD of the GCDs of the coefficients of the two polynomials.",
      "Hint 2: Use the Euclidean algorithm to find the GCD of two numbers, and apply this algorithm to the coefficients of the polynomials.",
      "Hint 3: Consider using a recursive function to find the GCD of the coefficients, and handle the case where one or both of the input polynomials have only one coefficient."
    ]
  },
  {
    "id": 1105,
    "title": "Largest Rectangle in a Histogram",
    "difficulty": "beginner",
    "category": "Math",
    "description": "Given a histogram with different bar heights, find the area of the largest rectangle that can be formed within the histogram. The histogram is represented as an array of integers, where each integer represents the height of a bar. The width of each bar is 1 unit.",
    "examples": [
      {
        "input": "[2, 1, 5, 6, 2, 3]",
        "output": "10"
      },
      {
        "input": "[1, 1]",
        "output": "2"
      },
      {
        "input": "[4, 2]",
        "output": "4"
      }
    ],
    "starterCode": "function largestRectangle(...args) {\n  // Your solution here\n  \n}",
    "testCases": [
      {
        "input": [
          [
            2,
            1,
            5,
            6,
            2,
            3
          ]
        ],
        "expected": 10
      },
      {
        "input": [
          [
            1,
            1
          ]
        ],
        "expected": 2
      },
      {
        "input": [
          [
            4,
            2
          ]
        ],
        "expected": 4
      },
      {
        "input": [
          [
            0,
            0,
            0
          ]
        ],
        "expected": 0
      },
      {
        "input": [
          [
            1
          ]
        ],
        "expected": 1
      }
    ],
    "functionName": "largestRectangle",
    "hints": [
      "Hint 1: Use a stack-based approach to keep track of the indices of the bars. When a smaller bar is encountered, calculate the area of the rectangle with the bar at the top of the stack as the smallest bar.",
      "Hint 2: Maintain a stack of indices of the bars. For each bar, pop all the bars from the stack that are higher than the current bar and calculate the area of the rectangle with the popped bar as the smallest bar.",
      "Hint 3: Handle the case when the stack is not empty after processing all the bars. Calculate the area of the rectangle with the bar at the top of the stack as the smallest bar and the width as the index of the bar plus 1."
    ]
  },
  {
    "id": 1106,
    "title": "Minimum Coins Needed to Make Change",
    "difficulty": "intermediate",
    "category": "Greedy",
    "description": "Given a set of coin denominations and a target amount of money, determine the minimum number of coins needed to make change for the target amount. You can use each coin denomination any number of times.",
    "examples": [
      {
        "input": "coins = [1, 2, 5], amount = 11",
        "output": "3"
      },
      {
        "input": "coins = [2], amount = 3",
        "output": "-1"
      },
      {
        "input": "coins = [1], amount = 0",
        "output": "0"
      }
    ],
    "starterCode": "function minCoinsNeeded(...args) {\n  // Your solution here\n  \n}",
    "testCases": [
      {
        "input": [
          [
            1,
            2,
            5
          ],
          11
        ],
        "expected": 3
      },
      {
        "input": [
          [
            2
          ],
          3
        ],
        "expected": -1
      },
      {
        "input": [
          [
            1
          ],
          0
        ],
        "expected": 0
      },
      {
        "input": [
          [
            1,
            4,
            5
          ],
          6
        ],
        "expected": 2
      },
      {
        "input": [
          [
            3,
            7
          ],
          12
        ],
        "expected": 4
      }
    ],
    "functionName": "minCoinsNeeded",
    "hints": [
      "Hint 1: Use dynamic programming to build up a solution, starting from the smallest possible amounts of money.",
      "Hint 2: Create a table to store the minimum number of coins needed for each amount up to the target amount, and fill it in iteratively using the available coin denominations.",
      "Hint 3: When filling in the table, consider using the minimum of the current value and 1 plus the minimum number of coins needed for the remaining amount after subtracting the current coin denomination."
    ]
  },
  {
    "id": 1108,
    "title": "Maximum Consecutive Sum",
    "difficulty": "beginner",
    "category": "Arrays",
    "description": "Given an array of integers, find the maximum sum of a subarray (a contiguous subset of the array). The subarray must contain at least one element.",
    "examples": [
      {
        "input": "[1, 2, 3, 4, 5]",
        "output": "15"
      },
      {
        "input": "[-1, -2, -3, -4, -5]",
        "output": "-1"
      },
      {
        "input": "[1, -2, 3, -4, 5]",
        "output": "8"
      }
    ],
    "starterCode": "function maxConsecutiveSum(arr) {\n  // Your solution here\n  \n}",
    "testCases": [
      {
        "input": [
          [
            1,
            2,
            3,
            4,
            5
          ]
        ],
        "expected": 15
      },
      {
        "input": [
          [
            -1,
            -2,
            -3,
            -4,
            -5
          ]
        ],
        "expected": -1
      },
      {
        "input": [
          [
            1,
            -2,
            3,
            -4,
            5
          ]
        ],
        "expected": 8
      },
      {
        "input": [
          [
            0,
            0,
            0,
            0,
            0
          ]
        ],
        "expected": 0
      },
      {
        "input": [
          [
            5
          ]
        ],
        "expected": 5
      }
    ],
    "functionName": "maxConsecutiveSum",
    "hints": [
      "Hint 1: Initialize variables to keep track of the maximum sum and the current sum. Iterate through the array to consider all possible subarrays.",
      "Hint 2: Use a technique like Kadane's algorithm to efficiently calculate the maximum sum of a subarray. This involves adding elements to the current sum as long as it remains positive.",
      "Hint 3: Be careful with edge cases, such as an empty array or an array with all negative numbers. Make sure to handle these cases correctly in your implementation."
    ]
  },
  {
    "id": 1109,
    "title": "Task Scheduler with Limited Workers",
    "difficulty": "intermediate",
    "category": "Greedy",
    "description": "Given a list of tasks with their durations and a limited number of workers, schedule the tasks to minimize the total time taken. Each worker can only work on one task at a time, and tasks cannot be interrupted once started.",
    "examples": [
      {
        "input": "[[1, 2], [2, 3], [3, 1]] with 2 workers",
        "output": "6"
      },
      {
        "input": "[[1, 5], [2, 2], [3, 1]] with 1 worker",
        "output": "8"
      },
      {
        "input": "[[1, 1], [2, 1], [3, 1]] with 3 workers",
        "output": "1"
      }
    ],
    "starterCode": "function scheduleTasks(tasks, workers) {\n  // Your solution here\n  \n}",
    "testCases": [
      {
        "input": [
          [
            [
              1,
              2
            ],
            [
              2,
              3
            ],
            [
              3,
              1
            ]
          ],
          2
        ],
        "expected": 6
      },
      {
        "input": [
          [
            [
              1,
              5
            ],
            [
              2,
              2
            ],
            [
              3,
              1
            ]
          ],
          1
        ],
        "expected": 8
      },
      {
        "input": [
          [
            [
              1,
              1
            ],
            [
              2,
              1
            ],
            [
              3,
              1
            ]
          ],
          3
        ],
        "expected": 1
      },
      {
        "input": [
          [],
          1
        ],
        "expected": 0
      },
      {
        "input": [
          [
            [
              1,
              1
            ]
          ],
          0
        ],
        "expected": -1
      }
    ],
    "functionName": "scheduleTasks",
    "hints": [
      "Hint 1: Sort the tasks based on their durations to prioritize the longest tasks first.",
      "Hint 2: Use a priority queue to keep track of the tasks that are being worked on and the time remaining for each task.",
      "Hint 3: When a worker becomes available, assign the next task with the longest remaining duration to that worker."
    ]
  },
  {
    "id": 1110,
    "title": "cyclicStringRotation",
    "difficulty": "advanced",
    "category": "Strings",
    "description": "Given a string and a rotation count, determine the lexicographically smallest string that can be obtained by rotating the input string. A rotation is defined as moving the last character of the string to the front.",
    "examples": [
      {
        "input": "'abc', 1",
        "output": "'bac'"
      },
      {
        "input": "'abcdef', 3",
        "output": "'defabc'"
      },
      {
        "input": "'abcdefgh', 8",
        "output": "'abcdefgh'"
      }
    ],
    "starterCode": "function cyclicStringRotation(str, count) {\n  // Your solution here\n  \n}",
    "testCases": [
      {
        "input": [
          "abc",
          1
        ],
        "expected": "bac"
      },
      {
        "input": [
          "abcdef",
          3
        ],
        "expected": "defabc"
      },
      {
        "input": [
          "abcdefgh",
          8
        ],
        "expected": "abcdefgh"
      },
      {
        "input": [
          "abc",
          3
        ],
        "expected": "abc"
      },
      {
        "input": [
          "a",
          1
        ],
        "expected": "a"
      }
    ],
    "functionName": "cyclicStringRotation",
    "hints": [
      "Consider using modular arithmetic to handle cases where the rotation count exceeds the length of the string",
      "Think about generating all possible rotations of the input string and sorting them lexicographically",
      "Use string slicing to efficiently extract the rotated substring"
    ]
  },
  {
    "id": 1114,
    "title": "Friend Suggestions",
    "difficulty": "beginner",
    "category": "Graphs",
    "description": "Given a social network represented as an adjacency list, suggest friends to a user based on their mutual friends. The function should return the suggested friends for a given user, sorted in descending order of their mutual friends count.",
    "examples": [
      {
        "input": "{\"graph\": {\"A\": [\"B\", \"C\"], \"B\": [\"A\", \"D\"], \"C\": [\"A\", \"D\"], \"D\": [\"B\", \"C\"]}, \"user\": \"A\"}",
        "output": "[\"D\"]"
      },
      {
        "input": "{\"graph\": {\"A\": [\"B\", \"C\"], \"B\": [\"A\", \"C\"], \"C\": [\"A\", \"B\"]}, \"user\": \"A\"}",
        "output": "[\"B\", \"C\"]"
      },
      {
        "input": "{\"graph\": {\"A\": [\"B\"], \"B\": [\"A\", \"C\"], \"C\": [\"B\"]}, \"user\": \"A\"}",
        "output": "[\"C\"]"
      }
    ],
    "starterCode": "function suggestFriends(graph, user) {\n  // Your solution here\n}",
    "testCases": [
      {
        "input": [
          {
            "A": [
              "B",
              "C"
            ],
            "B": [
              "A",
              "D"
            ],
            "C": [
              "A",
              "D"
            ],
            "D": [
              "B",
              "C"
            ]
          },
          "A"
        ],
        "expected": [
          "D"
        ]
      },
      {
        "input": [
          {
            "A": [
              "B",
              "C"
            ],
            "B": [
              "A",
              "C"
            ],
            "C": [
              "A",
              "B"
            ]
          },
          "A"
        ],
        "expected": [
          "B",
          "C"
        ]
      },
      {
        "input": [
          {
            "A": [
              "B"
            ],
            "B": [
              "A",
              "C"
            ],
            "C": [
              "B"
            ]
          },
          "A"
        ],
        "expected": [
          "C"
        ]
      },
      {
        "input": [
          {
            "A": []
          },
          "A"
        ],
        "expected": []
      },
      {
        "input": [
          {
            "A": [
              "B"
            ],
            "B": [
              "A"
            ]
          },
          "A"
        ],
        "expected": []
      }
    ],
    "functionName": "suggestFriends",
    "hints": [
      "To find suggested friends, consider the friends of the user's friends and count their mutual friends.",
      "Use a dictionary to store the count of mutual friends for each suggested friend and sort them in descending order.",
      "Make sure to exclude the user themselves and their existing friends from the suggested friends list."
    ]
  }
]